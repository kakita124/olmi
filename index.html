<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual - Plano Inclinado</title>
    <style>
        :root {
            --primary-color: #1a365d;
            --secondary-color: #2d3748;
            --accent-color: #3182ce;
            --light-color: #f7fafc;
            --dark-color: #1a202c;
            --success-color: #38a169;
            --warning-color: #d69e2e;
            --danger-color: #e53e3e;
            --text-color: #2d3748;
            --border-radius: 10px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }
       
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
       
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }
       
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
       
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
       
        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--success-color));
        }
       
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header-title {
            flex: 1;
        }
       
        h1 {
            font-size: 1.2rem;
            margin-bottom: 5px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }
       
        .subtitle {
            font-size: 0.8rem;
            opacity: 0.85;
            font-weight: 400;
        }
       
        .content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 25px;
            margin-bottom: 30px;
        }
       
        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
       
        .panel {
            background: white;
            border-radius: var(--border-radius);
            padding: 28px;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .panel:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .panel h2 {
            margin-bottom: 22px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e2e8f0;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }
       
        .panel h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 22px;
            background: var(--accent-color);
            margin-right: 12px;
            border-radius: 2px;
        }
       
        .tabs {
            display: flex;
            margin-bottom: 22px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 8px 8px 0 0;
            padding: 5px;
        }
       
        .tab {
            padding: 12px 22px;
            cursor: pointer;
            border-radius: 6px;
            transition: var(--transition);
            font-weight: 500;
            flex: 1;
            text-align: center;
            color: var(--secondary-color);
        }
       
        .tab.active {
            background: white;
            color: var(--accent-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
       
        .tab:hover:not(.active) {
            background: rgba(49, 130, 206, 0.05);
        }
       
        .tab-content {
            display: none;
        }
       
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
       
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
       
        .input-group {
            margin-bottom: 22px;
        }
       
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--secondary-color);
            font-size: 0.95rem;
        }
       
        input[type="number"], select {
            width: 100%;
            padding: 14px;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
            background: white;
        }
       
        input[type="number"]:focus, select:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.15);
        }
       
        .input-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
       
        .input-container input {
            flex: 1;
        }
       
        .unit {
            min-width: 45px;
            text-align: center;
            font-weight: 500;
            color: var(--secondary-color);
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
       
        .range-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
       
        .range-container input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
       
        .range-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
       
        .range-value {
            min-width: 45px;
            text-align: center;
            font-weight: 600;
            background: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            color: var(--primary-color);
        }
       
        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 14px 22px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: var(--transition);
            width: 100%;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
       
        button:hover {
            background: #2c5aa0;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
       
        .simulation-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
       
        .canvas-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            flex: 1;
            min-height: 450px;
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .canvas-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: var(--border-radius);
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }
       
        .data-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 18px;
            margin-top: 22px;
        }
       
        .data-item {
            background: white;
            padding: 18px;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border-left: 4px solid var(--accent-color);
        }
       
        .data-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
       
        .data-label {
            font-size: 0.9rem;
            color: var(--secondary-color);
            margin-bottom: 8px;
            font-weight: 500;
        }
       
        .data-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--primary-color);
        }
       
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 22px;
        }
       
        .controls button {
            flex: 1;
            margin-top: 0;
        }
       
        .reset-btn {
            background: var(--danger-color);
        }
       
        .reset-btn:hover {
            background: #c53030;
        }
       
        .pause-btn {
            background: var(--warning-color);
        }
       
        .pause-btn:hover {
            background: #b7791f;
        }
       
        .export-btn {
            background: var(--success-color);
        }
       
        .export-btn:hover {
            background: #2f855a;
        }
       
        .pulley-config {
            margin-top: 22px;
            padding-top: 22px;
            border-top: 1px solid #e2e8f0;
        }
       
        .pulley-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 18px;
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
        }
       
        .pulley-toggle input {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
        }
       
        .pulley-options {
            padding: 18px;
            background: #f8fafc;
            border-radius: var(--border-radius);
            margin-top: 12px;
            border: 1px solid #e2e8f0;
        }
       
        .history-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            min-height: 320px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .history-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .history-list {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 10px;
        }
       
        .history-item {
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid var(--accent-color);
            transition: var(--transition);
        }
       
        .history-item:hover {
            background: #edf2f7;
            transform: translateX(5px);
        }
       
        .history-details {
            flex: 1;
        }
       
        .history-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
       
        .history-params {
            font-size: 0.85rem;
            color: var(--secondary-color);
        }
       
        .history-date {
            font-size: 0.8rem;
            color: var(--secondary-color);
            margin-top: 3px;
        }
       
        .history-actions {
            display: flex;
            gap: 8px;
        }
       
        .history-btn-small {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: var(--transition);
        }
       
        .history-btn-small:hover {
            background: #2c5aa0;
        }
       
        .history-btn-small.delete {
            background: var(--danger-color);
        }
       
        .history-btn-small.delete:hover {
            background: #c53030;
        }
       
        .empty-history {
            text-align: center;
            padding: 30px;
            color: var(--secondary-color);
            font-style: italic;
        }
       
        footer {
            text-align: center;
            padding: 25px;
            margin-top: 35px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            font-size: 0.95rem;
            color: var(--secondary-color);
            border-top: 4px solid var(--accent-color);
        }
       
        .info-panel {
            background: white;
            border-radius: var(--border-radius);
            padding: 28px;
            box-shadow: var(--box-shadow);
            margin-top: 25px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .info-panel:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .info-panel h2 {
            margin-bottom: 18px;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }
       
        .info-panel h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 22px;
            background: var(--accent-color);
            margin-right: 12px;
            border-radius: 2px;
        }
       
        .formula {
            background: #f8fafc;
            padding: 18px;
            border-radius: var(--border-radius);
            margin: 18px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            border-left: 4px solid var(--accent-color);
            font-weight: 600;
            color: var(--primary-color);
        }
       
        .variable {
            font-style: italic;
            color: var(--accent-color);
            font-weight: 500;
        }
       
        .theory-content {
            line-height: 1.8;
        }
       
        .theory-content p {
            margin-bottom: 18px;
        }
       
        .validation-message {
            color: var(--danger-color);
            font-size: 0.9rem;
            margin-top: 8px;
            display: none;
            font-weight: 500;
        }
       
        .icon {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
       
        /* Estilos para el sistema de notificaciones */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        }
       
        .notification {
            background: white;
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-left: 4px solid var(--accent-color);
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease;
        }
       
        .notification-icon {
            margin-right: 10px;
            font-size: 1.2rem;
        }
       
        .notification-content {
            flex: 1;
        }
       
        .notification-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--primary-color);
        }
       
        .notification-message {
            font-size: 0.9rem;
            color: var(--secondary-color);
            line-height: 1.4;
        }
       
        .notification-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 0;
            margin: 0;
            width: auto;
        }
       
        .notification-close:hover {
            color: var(--danger-color);
            transform: none;
            box-shadow: none;
        }
       
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
       
        /* Estilos para la sección de resultados */
        .results-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            margin-top: 25px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .results-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .results-explanation {
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 15px;
            border-left: 4px solid var(--success-color);
        }
       
        .results-explanation h4 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }
       
        .results-explanation p {
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-title">
                    <h1>Laboratorio Virtual: Plano Inclinado</h1>
                    <p class="subtitle">Simulador interactivo para el estudio de la física del movimiento</p>
                </div>
            </div>
        </header>
       
        <div class="content">
            <div class="panel">
                <h2>Configuración del Experimento</h2>
               
                <div class="tabs">
                    <div class="tab active" data-tab="basic">Básico</div>
                    <div class="tab" data-tab="pulley">Poleas</div>
                </div>
               
                <div class="tab-content active" id="basic-tab">
                    <div class="input-group">
                        <label for="mass-input">Masa del objeto (M)</label>
                        <div class="input-container">
                            <input type="number" id="mass-input" min="0.1" value="5" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                        <div class="validation-message" id="mass-validation"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="angle-input">Ángulo del plano (θ)</label>
                        <div class="range-container">
                            <input type="range" id="angle-range" min="1" max="90" value="30" step="1">
                            <span class="range-value" id="angle-value">30°</span>
                        </div>
                        <input type="number" id="angle-input" min="1" max="90" value="30" step="1" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="friction-input">Coeficiente de fricción (μ)</label>
                        <div class="range-container">
                            <input type="range" id="friction-range" min="0" max="1" value="0.1" step="0.01">
                            <span class="range-value" id="friction-value">0.10</span>
                        </div>
                        <input type="number" id="friction-input" min="0" max="1" value="0.1" step="0.01" style="display: none;">
                    </div>
                
                    <div class="input-group">
                        <label for="length-input">Longitud del plano (L)</label>
                        <div class="input-container">
                            <input type="number" id="length-input" min="1" value="8" step="0.5">
                            <span class="unit">M</span>
                        </div>
                    </div>
                 
                    <div class="input-group">
                        <label for="gravity-input">Gravedad (g)</label>
                        <div class="input-container">
                            <input type="number" id="gravity-input" value="9.8" min="1" step="0.1">
                            <span class="unit">M/s²</span>
                        </div>
                    </div>
                </div>
    
            
                <div class="tab-content" id="pulley-tab">
                    <div class="input-group">
                        <label for="mass-input-pulley">Masa del objeto (M)</label>
                        <div class="input-container">
                            <input type="number" id="mass-input-pulley" min="0.1" value="5" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                        <div class="validation-message" id="mass-validation-pulley"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="counter-mass-input">Masa contrapeso (M₂)</label>
                        <div class="input-container">
                            <input type="number" id="counter-mass-input" min="0.1" value="3" step="0.1">
                            <span class="unit">kg</span>
                        </div>
                        <div class="validation-message" id="counter-mass-validation"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="angle-input-pulley">Ángulo del plano (θ)</label>
                        <div class="range-container">
                            <input type="range" id="angle-range-pulley" min="1" max="90" value="30" step="1">
                            <span class="range-value" id="angle-value-pulley">30°</span>
                        </div>
                        <input type="number" id="angle-input-pulley" min="1" max="90" value="30" step="1" style="display: none;">
                    </div>
        
            
                    <div class="input-group">
                        <label for="friction-input-pulley">Coeficiente de fricción (μ)</label>
                        <div class="range-container">
                            <input type="range" id="friction-range-pulley" min="0" max="1" value="0.1" step="0.01">
                            <span class="range-value" id="friction-value-pulley">0.10</span>
                        </div>
                        <input type="number" id="friction-input-pulley" min="0" max="1" value="0.1" step="0.01" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="length-input-pulley">Longitud del plano (L)</label>
                        <div class="input-container">
                            <input type="number" id="length-input-pulley" min="1" value="8" step="0.5">
                            <span class="unit">M</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="gravity-input-pulley">Gravedad (g)</label>
                        <div class="input-container">
                            <input type="number" id="gravity-input-pulley" value="9.8" min="1" step="0.1">
                            <span class="unit">M/s²</span>
                        </div>
                    </div>
                </div>
               
                <button id="start-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Iniciar Simulación
                </button>
                <button id="save-config-btn" style="background: var(--success-color);">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                    Guardar Configuración
                </button>
                <button id="reset-btn" class="reset-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                    </svg>
                    Reiniciar
                </button>
            </div>
           
            <div class="simulation-area">
                <div class="canvas-container">
                    <h2>Visualización del Experimento</h2>
                    <canvas id="simulation-canvas"></canvas>
                </div>
                <div class="data-display">
                    <div class="data-item">
                        <div class="data-label">Tiempo</div>
                        <div class="data-value" id="time-value">0.00 s</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Posición</div>
                        <div class="data-value" id="position-value">0.00 M</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Velocidad</div>
                        <div class="data-value" id="velocity-value">0.00 M/s</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Aceleración</div>
                        <div class="data-value" id="acceleration-value">0.00 M/s²</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Fuerza Net</div>
                        <div class="data-value" id="force-value">0.00 N</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Energía</div>
                        <div class="data-value" id="energy-value">0.00 J</div>
                    </div>
                </div>
                <div class="controls">
                    <button id="pause-btn" class="pause-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                        Pausar
                    </button>
                    <button id="export-btn" class="export-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                        </svg>
                        Exportar Datos
                    </button>
                </div>
                <div class="history-container">
                    <h2>Historial de Configuraciones</h2>
                    <div class="history-list" id="history-list">
                        <div class="empty-history" id="empty-history">No hay configuraciones guardadas.
                            Guarda una configuración para verla aquí.</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="results-container">
            <h2>Resultados y Explicación del Sistema</h2>
            <div class="results-explanation">
                <h4>Análisis del Movimiento</h4>
                <p id="movement-analysis">El sistema está en reposo.
                    Inicie la simulación para ver el análisis del movimiento.</p>
                <h4>Comportamiento del Sistema</h4>
                <p id="system-behavior">El objeto permanecerá en reposo o se moverá dependiendo de la relación entre la fuerza gravitatoria paralela al plano y la fuerza de fricción.</p>
                <h4>Explicación del Desplazamiento</h4>
                <p id="displacement-explanation">El desplazamiento del objeto está determinado por la fuerza neta que actúa sobre él.
                    Si la componente gravitatoria paralela al plano supera la fuerza de fricción, el objeto acelerará hacia abajo del plano.</p>
            </div>
        </div>
        <div class="info-panel">
            <h2>Fundamentos Teóricos</h2>
            <div class="tabs">
                <div class="tab active" data-tab="theory">Teoría</div>
                <div class="tab" data-tab="formulas">Fórmulas</div>
                <div class="tab" data-tab="instructions">Instrucciones</div>
            </div>
            <div class="tab-content active" id="theory-tab">
                <div class="theory-content">
                    <p>Un plano inclinado es una superficie plana que forma un ángulo agudo con la horizontal.
                        Se utiliza para elevar cuerpos a una cierta altura con una fuerza menor que el peso del cuerpo.</p>
                    <p>Las fuerzas que actúan sobre un objeto en un plano inclinado son:</p>
                    <ul>
                        <li><span class="variable">Peso (mg)</span>: Fuerza gravitatoria dirigida hacia el centro de la Tierra.</li>
                        <li><span class="variable">Fuerza normal (N)</span>: Fuerza perpendicular al plano ejercida por la superficie.</li>
                        <li><span class="variable">Fuerza de fricción (f)</span>: Fuerza que se opone al movimiento, paralela al plano.</li>
                    </ul>
                    <p>Cuando se añade un sistema de poleas, se introduce una fuerza adicional que puede modificar el movimiento del objeto en el plano inclinado.</p>
                </div>
            </div>
            <div class="tab-content" id="formulas-tab">
                <div class="theory-content">
                    <p><strong>Fuerzas en un plano inclinado (Serway):</strong></p>
                    <div class="formula"> F<sub>gx</sub> = mg sen θ </div>
                    <div class="formula"> F<sub>gy</sub> = mg cos θ </div>
                    <div class="formula"> F<sub>n</sub> = mg cos θ </div>
                    <div class="formula"> f<sub>k</sub> = μ<sub>k</sub> F<sub>n</sub> = μ<sub>k</sub> mg cos θ </div>
                    <div class="formula"> F<sub>neta</sub> = mg sen θ - f<sub>k</sub> </div>
                    <div class="formula"> a = F<sub>neta</sub> / m </div>
                    <p><strong>Con sistema de poleas:</strong></p>
                    <div class="formula"> F<sub>neta</sub> = mg sen θ - f<sub>k</sub> - T </div>
                    <div class="formula"> T = m<sub>2</sub>g - m<sub>2</sub>a </div>
                </div>
            </div>
            <div class="tab-content" id="instructions-tab">
                <div class="theory-content">
                    <p>Instrucciones del sistema:</p>
                    <ul>
                        <li><strong>Primer paso:</strong> Seleccionar el sistema que desee utilzar (Básico o con polea).</li>
                        <li><strong>Segundo paso:</strong> Insertar datos correspondientes al sistema seleccionado y apretar el boton de iniciar simulación.</li>
                        <li><strong>Tercer paso:</strong> Al detenerse, se puede utilizar la opción reiniciar o exportar datos, al exportarlos se entregará un documento.</li>
                        <li><strong>Nueva función:</strong> Puede guardar configuraciones para usarlas posteriormente desde el panel de historial.</li>
                    </ul>
                </div>
            </div>
        </div>
        <footer>
            <p>Laboratorio Virtual de Física - Simulador de Plano Inclinado con Poleas y sin poleas</p>
            <p>© 2023 - Departamento de Física - Universidad Virtual</p>
        </footer>
    </div>
    <div class="notification-container" id="notification-container"></div>
    <script>
        // Elementos del DOM
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
        // Inputs numéricos
        const massInput = document.getElementById('mass-input');
        const angleInput = document.getElementById('angle-input');
        const angleRange = document.getElementById('angle-range');
        const angleValue = document.getElementById('angle-value');
        const frictionInput = document.getElementById('friction-input');
        const frictionRange = document.getElementById('friction-range');
        const frictionValue = document.getElementById('friction-value');
        const lengthInput = document.getElementById('length-input');
        const gravityInput = document.getElementById('gravity-input');
        // Inputs de la pestaña Poleas
        const massInputPulley = document.getElementById('mass-input-pulley');
        const angleInputPulley = document.getElementById('angle-input-pulley');
        const angleRangePulley = document.getElementById('angle-range-pulley');
        const angleValuePulley = document.getElementById('angle-value-pulley');
        const frictionInputPulley = document.getElementById('friction-input-pulley');
        const frictionRangePulley = document.getElementById('friction-range-pulley');
        const frictionValuePulley = document.getElementById('friction-value-pulley');
        const lengthInputPulley = document.getElementById('length-input-pulley');
        const gravityInputPulley = document.getElementById('gravity-input-pulley');
        // Configuración de poleas
        const counterMassInput = document.getElementById('counter-mass-input');
        // Botones
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const exportBtn = document.getElementById('export-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        // Historial
        const historyList = document.getElementById('history-list');
        const emptyHistory = document.getElementById('empty-history');
        // Valores de datos
        const timeValue = document.getElementById('time-value');
        const positionValue = document.getElementById('position-value');
        const velocityValue = document.getElementById('velocity-value');
        const accelerationValue = document.getElementById('acceleration-value');
        const forceValue = document.getElementById('force-value');
        const energyValue = document.getElementById('energy-value');
        // Mensajes de validación
        const massValidation = document.getElementById('mass-validation');
        const massValidationPulley = document.getElementById('mass-validation-pulley');
        const counterMassValidation = document.getElementById('counter-mass-validation');
        // Elementos de resultados
        const movementAnalysis = document.getElementById('movement-analysis');
        const systemBehavior = document.getElementById('system-behavior');
        const displacementExplanation = document.getElementById('displacement-explanation');

        // Variables de simulación
        let animationId;
        let isRunning = false;
        let isPaused = false;
        let currentTime = 0;
        let position = 0;
        let velocity = 0;
        let acceleration = 0;
        let netForce = 0;
        let energy = 0;
        let simulationData = [];

        // Parámetros iniciales
        let mass = parseFloat(massInput.value);
        let angle = parseFloat(angleInput.value);
        let friction = parseFloat(frictionInput.value);
        let length = parseFloat(lengthInput.value);
        let gravity = parseFloat(gravityInput.value);
        let usePulley = false;
        let pulleyConfig = { counterMass: parseFloat(counterMassInput.value) };

        // Variables para controlar notificaciones
        let angleChanged = false;
        let frictionChanged = false;

        // Historial de configuraciones
        let configHistory = JSON.parse(localStorage.getItem('inclinedPlaneHistory')) || [];

        // Inicializar el historial
        renderHistory();

        // ----------------------------------------------------------------------
        // Funciones de utilidad y dibujo (Aquí está la modificación del ángulo)
        // ----------------------------------------------------------------------

        /**
         * Dibuja el símbolo del ángulo en la esquina inferior izquierda (P1),
         * marcando el ángulo theta (θ) entre la rampa y la horizontal (suelo).
         * @param {CanvasRenderingContext2D} ctx - Contexto de dibujo del canvas.
         * @param {number} x - Coordenada X del vértice (esquina inferior izquierda P1).
         * @param {number} y - Coordenada Y del vértice (esquina inferior izquierda P1).
         * @param {number} angleRad - Valor del ángulo en radianes.
         * @param {number} radius - Radio del arco.
         * @param {string} color - Color del ángulo.
         * @param {string} label - Etiqueta del ángulo ('θ').
         */
        function drawAngleAtBaseHorizontal(ctx, x, y, angleRad, radius, color = '#e53e3e', label = 'θ') {
            ctx.save();
            ctx.beginPath();

            // Arco: desde la horizontal (ángulo 0) hasta la rampa (ángulo -angleRad)
            // El sentido antihorario (true) es esencial para que dibuje el ángulo positivo
            // desde la horizontal hacia arriba.
            ctx.arc(x, y, radius, 0, -angleRad, true); 
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Coloca la etiqueta del ángulo (θ)
            ctx.fillStyle = color;
            ctx.font = '24px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Posición para la etiqueta θ: a medio camino en el arco
            const midAngle = -angleRad / 2;
            const labelX = x + (radius + 15) * Math.cos(midAngle); 
            const labelY = y + (radius + 15) * Math.sin(midAngle); 
            
            ctx.fillText(label, labelX, labelY); 

            ctx.restore();
        }

        function drawLine(ctx, x1, y1, x2, y2, color = 'black', width = 2) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawRect(ctx, x, y, w, h, color = 'blue') {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawBlock(ctx, x, y, size, angleRad, color = '#3182ce') {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(-angleRad); // Rotar para que se alinee con el plano
            
            // Dibuja el bloque centrado en (0, 0) y luego se traslada
            const halfSize = size / 2;
            ctx.fillStyle = color;
            ctx.fillRect(-halfSize, -halfSize, size, size);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(-halfSize, -halfSize, size, size);

            ctx.restore();
        }

        function drawPulley(ctx, x, y, radius, color = 'gray') {
            // Rueda de la polea
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.stroke();

            // Centro
            ctx.beginPath();
            ctx.fillStyle = 'black';
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();

            // Soporte (opcional, simplificado)
            drawLine(ctx, x, y - radius, x, y - radius - 15, 'black', 4);
        }

        function drawInclinedPlane(ctx, angle, length, usePulley) {
            const W = canvas.width;
            const H = canvas.height;
            const angleRad = angle * Math.PI / 180;
            const padding = 50;

            // Coordenadas del triángulo (Plano inclinado)
            // P1: Esquina inferior izquierda (base del plano)
            const P1_X = padding;
            const P1_Y = H - padding;
            
            // P3: Esquina inferior derecha (depende del espacio)
            const base = (W - 2 * padding) * 0.8;
            const P3_X = P1_X + base;

            // P2: Esquina superior (altura)
            const height = base * Math.tan(angleRad);
            const P2_X = P1_X;
            const P2_Y = P1_Y - height;
            
            // Escala para el dibujo: Convertir Longitud (M) a Longitud del dibujo
            const drawingLength = Math.sqrt(base * base + height * height);
            const scale = length / drawingLength; 

            // 1. Dibuja el Plano Inclinado (Triángulo)
            ctx.beginPath();
            ctx.moveTo(P1_X, P1_Y); // P1 (Base)
            ctx.lineTo(P3_X, P1_Y); // P3 (Suelo horizontal)
            ctx.lineTo(P2_X, P2_Y); // P2 (Altura)
            ctx.closePath();
            
            ctx.fillStyle = '#cbd5e0'; // Color de la rampa
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Dibuja la base y la altura para el triángulo de referencia (opcional)
            drawLine(ctx, P1_X, P1_Y, P3_X, P1_Y, '#2d3748', 3); // Base Horizontal (Suelo)
            drawLine(ctx, P1_X, P1_Y, P2_X, P2_Y, '#2d3748', 3); // Soporte Vertical
            
            // 2. Dibuja el Símbolo del Ángulo (θ) - EN LA ESQUINA INFERIOR IZQUIERDA (P1)
            // Llama a la función CORREGIDA
            drawAngleAtBaseHorizontal(ctx, P1_X, P1_Y, angleRad, 40); 
            
            // 3. Dibuja la Polea si está activada
            let pulleyX = P3_X;
            let pulleyY = P1_Y;
            if (usePulley) {
                // Coloca la polea en el extremo superior del plano inclinado (P2)
                pulleyX = P1_X + base * Math.cos(angleRad) * Math.cos(angleRad); // Esto es incorrecto para P2
                pulleyX = P1_X + height * Math.cos(angleRad); // Proyección en X de P2
                pulleyY = P1_Y - height * Math.cos(angleRad); // Proyección en Y de P2
                
                // Cálculo simple de P2 (extremo superior de la rampa)
                // Usaremos P_rampa_extremo: P1_X + Base_rampa en X, P1_Y - Altura_rampa en Y
                const rampEndX = P1_X + base * Math.cos(angleRad); // Esto NO es correcto para el vértice P2, es para un punto intermedio
                
                // El punto P2 es (P1_X, P1_Y - height). La polea debe ir allí, o en el extremo de la hipotenusa.
                
                // Usaremos el extremo superior de la hipotenusa (P_hipotenusa_end)
                const rampLength = length / scale;
                const P_hipotenusa_end_X = P1_X + rampLength * Math.cos(angleRad);
                const P_hipotenusa_end_Y = P1_Y - rampLength * Math.sin(angleRad);
                
                // Usaremos un punto fijo en el dibujo (el vértice superior P2 para simplificar la cadena)
                // La polea se dibujará justo encima del extremo superior de la hipotenusa
                
                // Coordenadas correctas para la polea en el extremo superior de la rampa
                pulleyX = P1_X + base * 0.95; // Un poco antes del final de la base
                pulleyY = P1_Y - (P1_X + base * 0.95 - P1_X) * Math.tan(angleRad);

                drawPulley(ctx, pulleyX, pulleyY, 15);
            }
            
            return { P1_X, P1_Y, P3_X, P3_Y: P1_Y, base, height, scale, angleRad, pulleyX, pulleyY };
        }

        function drawSimulation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obtener parámetros
            const currentMass = usePulley ? parseFloat(massInputPulley.value) : parseFloat(massInput.value);
            const currentAngle = usePulley ? parseFloat(angleInputPulley.value) : parseFloat(angleInput.value);
            const currentLength = usePulley ? parseFloat(lengthInputPulley.value) : parseFloat(lengthInput.value);

            const { P1_X, P1_Y, scale, angleRad, pulleyX, pulleyY } = drawInclinedPlane(ctx, currentAngle, currentLength, usePulley);

            // Calcular la posición del bloque en el plano inclinado (convertir 'position' de M a pixeles)
            const positionPx = position / scale; 
            
            // Coordenadas del centro del bloque (desplazamiento a lo largo de la rampa)
            const blockRadius = 25;
            // La posición inicial (0) es la base. El desplazamiento es a lo largo de la hipotenusa.
            const blockCenterX = P1_X + positionPx * Math.cos(angleRad);
            const blockCenterY = P1_Y - positionPx * Math.sin(angleRad);
            
            // 4. Dibuja el Bloque
            drawBlock(ctx, blockCenterX, blockCenterY, blockRadius * 2, angleRad, usePulley ? '#e53e3e' : '#3182ce');

            // 5. Dibuja Fuerzas (Vector de Peso y Normal para referencia)
            // (La implementación de las fuerzas es compleja y no es necesaria para el ángulo)

            // 6. Dibuja la Cuerda y el Contrapeso (si se usa polea)
            if (usePulley) {
                const counterMass = parseFloat(counterMassInput.value);
                const blockTopEdgeX = blockCenterX + blockRadius * Math.sin(angleRad);
                const blockTopEdgeY = blockCenterY + blockRadius * Math.cos(angleRad);

                // Cuerda en el plano inclinado
                drawLine(ctx, blockCenterX, blockCenterY, pulleyX, pulleyY, 'gray', 3);

                // Cuerda vertical que cae
                const stringLength = canvas.height - pulleyY - padding;
                drawLine(ctx, pulleyX, pulleyY, pulleyX, pulleyY + stringLength, 'gray', 3);
                
                // Contrapeso (solo dibujamos la masa, la posición exacta depende de la longitud de la cuerda)
                const counterMassY = pulleyY + stringLength;
                drawBlock(ctx, pulleyX, counterMassY + 20, 30, 0, '#38a169');
            }
        }
        
        function setupCanvas() {
            const container = document.getElementById('simulation-canvas').parentNode;
            canvas.width = container.clientWidth;
            canvas.height = Math.max(container.clientHeight, 400); // Altura mínima
        }

        // ----------------------------------------------------------------------
        // Funciones de cálculo y simulación
        // ----------------------------------------------------------------------

        function calculateAcceleration(m, angle, friction, g, L, m2 = 0) {
            const angleRad = angle * Math.PI / 180;
            const F_gx = m * g * Math.sin(angleRad);
            const F_n = m * g * Math.cos(angleRad);
            const F_k = friction * F_n;

            let netForce;
            let accelerationValue;
            let isMovingUp = false;

            if (usePulley) {
                // Sistema con Polea
                const F_g2 = m2 * g;
                
                // Determine la dirección potencial de movimiento si el sistema está en reposo o no
                if (F_g2 > (F_gx + F_k)) {
                    // M2 jala hacia abajo, M1 sube.
                    netForce = F_g2 - F_gx - F_k;
                    accelerationValue = netForce / (m + m2);
                } else if ((F_gx - F_k) > F_g2) {
                    // M1 jala hacia abajo, M2 sube.
                    netForce = F_gx - F_k - F_g2;
                    accelerationValue = netForce / (m + m2);
                } else {
                    // Equilibrio o fricción estática mayor que la fuerza neta motriz
                    netForce = 0;
                    accelerationValue = 0;
                }
            } else {
                // Sistema Básico (objeto desliza hacia abajo)
                netForce = F_gx - F_k;

                if (netForce > 0) {
                    // Acelera hacia abajo
                    accelerationValue = netForce / m;
                } else {
                    // Reposo o fricción evita el movimiento
                    accelerationValue = 0;
                    netForce = 0;
                }
            }
            
            return { acceleration: accelerationValue, netForce, isMovingUp };
        }

        function updateSimulation(deltaTime) {
            const currentMass = usePulley ? parseFloat(massInputPulley.value) : parseFloat(massInput.value);
            const currentAngle = usePulley ? parseFloat(angleInputPulley.value) : parseFloat(angleInput.value);
            const currentFriction = usePulley ? parseFloat(frictionInputPulley.value) : parseFloat(frictionInput.value);
            const currentLength = usePulley ? parseFloat(lengthInputPulley.value) : parseFloat(lengthInput.value);
            const currentGravity = usePulley ? parseFloat(gravityInputPulley.value) : parseFloat(gravityInput.value);
            const counterMass = usePulley ? parseFloat(counterMassInput.value) : 0;
            
            const { acceleration: acc, netForce: force } = calculateAcceleration(currentMass, currentAngle, currentFriction, currentGravity, currentLength, counterMass);
            
            acceleration = acc;
            netForce = force;

            // Integración de movimiento
            // v = v₀ + a*t
            velocity += acceleration * deltaTime;
            
            // x = x₀ + v₀*t + 0.5*a*t²
            position += velocity * deltaTime + 0.5 * acceleration * deltaTime * deltaTime;
            
            // Condición de parada (si el bloque llega al final del plano)
            if (position >= currentLength) {
                position = currentLength;
                velocity = 0;
                isRunning = false;
                cancelAnimationFrame(animationId);
                showNotification('Simulación Terminada', 'El objeto ha llegado al final del plano inclinado.', 'success');
            } else if (position < 0) { // Si el movimiento es hacia arriba y se detiene antes de L
                position = 0;
                velocity = 0;
                isRunning = false;
                cancelAnimationFrame(animationId);
                showNotification('Simulación Terminada', 'El objeto ha llegado a la base del plano inclinado.', 'success');
            }

            // Calcular Energía (Potencial + Cinética)
            const angleRad = currentAngle * Math.PI / 180;
            const height = position * Math.sin(angleRad); // Altura vertical
            const potentialEnergy = currentMass * currentGravity * height;
            const kineticEnergy = 0.5 * currentMass * velocity * velocity;
            energy = potentialEnergy + kineticEnergy;

            // Actualizar tiempo
            currentTime += deltaTime;

            // Guardar datos
            simulationData.push({
                time: currentTime,
                position,
                velocity,
                acceleration,
                netForce,
                energy
            });

            // Actualizar visualización de datos
            timeValue.textContent = `${currentTime.toFixed(2)} s`;
            positionValue.textContent = `${position.toFixed(2)} M`;
            velocityValue.textContent = `${velocity.toFixed(2)} M/s`;
            accelerationValue.textContent = `${acceleration.toFixed(2)} M/s²`;
            forceValue.textContent = `${netForce.toFixed(2)} N`;
            energyValue.textContent = `${energy.toFixed(2)} J`;
            
            // Actualizar explicación de resultados
            updateResultsExplanation();
        }

        let lastTime = 0;
        const maxTimeStep = 1/60; // Máximo paso de tiempo para estabilidad

        function animate(timestamp) {
            if (!isRunning || isPaused) return;

            const deltaTime = Math.min((timestamp - lastTime) / 1000, maxTimeStep);
            lastTime = timestamp;

            updateSimulation(deltaTime);
            drawSimulation();

            animationId = requestAnimationFrame(animate);
        }

        // ----------------------------------------------------------------------
        // Funciones de control e interacción
        // ----------------------------------------------------------------------

        function showNotification(title, message, type = 'info') {
            const notificationContainer = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = 'notification';
            let icon = 'ℹ️';
            if (type === 'warning') icon = '⚠️';
            if (type === 'error') icon = '❌';
            if (type === 'success') icon = '✅';
            
            let borderColor = '';
            if (type === 'warning') borderColor = 'var(--warning-color)';
            else if (type === 'error') borderColor = 'var(--danger-color)';
            else if (type === 'success') borderColor = 'var(--success-color)';
            else borderColor = 'var(--accent-color)';
            
            notification.style.borderLeftColor = borderColor;

            notification.innerHTML = `
                <div class="notification-icon">${icon}</div>
                <div class="notification-content">
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close">&times;</button>
            `;
            notificationContainer.appendChild(notification);

            notification.querySelector('.notification-close').addEventListener('click', function() {
                notification.remove();
            });

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }

        function updateResultsExplanation() {
            const currentMass = usePulley ? parseFloat(massInputPulley.value) : parseFloat(massInput.value);
            const currentAngle = usePulley ? parseFloat(angleInputPulley.value) : parseFloat(angleInput.value);
            const currentFriction = usePulley ? parseFloat(frictionInputPulley.value) : parseFloat(frictionInput.value);
            const currentGravity = usePulley ? parseFloat(gravityInputPulley.value) : parseFloat(gravityInput.value);
            const counterMass = usePulley ? parseFloat(counterMassInput.value) : 0;
            
            const angleRad = currentAngle * Math.PI / 180;
            const gravitationalForce = currentMass * currentGravity * Math.sin(angleRad);
            const normalForce = currentMass * currentGravity * Math.cos(angleRad);
            const frictionForce = currentFriction * normalForce;
            
            let analysisText = "";
            let behaviorText = "";
            let displacementText = "";
            let netForceStatic;

            if (usePulley) {
                const F_g2 = counterMass * currentGravity;
                
                // Fuerza neta potencial hacia M1 abajo
                const F_net_down = gravitationalForce - frictionForce - F_g2;
                // Fuerza neta potencial hacia M2 abajo (M1 arriba)
                const F_net_up = F_g2 - gravitationalForce - frictionForce;
                
                // Mínima fricción estática para que permanezca en reposo (F_s_max = mu_s * F_n)
                // Aquí usamos mu_k (coeficiente cinético) como aproximación de mu_s
                const F_s_max = frictionForce; 
                
                if (position > 0 && isRunning) {
                     // Si el movimiento ya está en curso, usamos la aceleración calculada en updateSimulation
                    analysisText = `El sistema se mueve con una aceleración neta de ${acceleration.toFixed(2)} M/s².`;
                    behaviorText = `El objeto principal (${currentMass} Kg) se desliza ${acceleration > 0 ? 'hacia abajo' : 'hacia arriba'} del plano con la masa contrapeso (${counterMass} Kg) dictando la fuerza motriz.`;
                } else if (F_net_down > 0) {
                    analysisText = `El objeto se moverá hacia **abajo** del plano. La fuerza motriz neta es de ${F_net_down.toFixed(2)} N.`;
                    behaviorText = `La componente gravitatoria de M (${gravitationalForce.toFixed(2)} N) supera la suma de la fricción y la fuerza del contrapeso.`;
                } else if (F_net_up > 0) {
                    analysisText = `El objeto se moverá **hacia arriba** del plano, jalado por el contrapeso. La fuerza motriz neta es de ${F_net_up.toFixed(2)} N.`;
                    behaviorText = `La fuerza gravitatoria del contrapeso (M₂ = ${F_g2.toFixed(2)} N) supera la fuerza gravitatoria paralela de M y la fricción.`;
                } else {
                    analysisText = `El sistema permanece en **equilibrio estático**.`;
                    behaviorText = `La fuerza neta que intenta mover el sistema no es suficiente para superar la fuerza de fricción estática (${F_s_max.toFixed(2)} N).`;
                }

                displacementText = `El desplazamiento máximo es la longitud del plano (${currentLength.toFixed(2)} M). El movimiento y la aceleración se calculan considerando la inercia total (M + M₂).`;

            } else {
                // Sistema Básico (sin polea)
                netForceStatic = gravitationalForce - frictionForce;
                
                if (netForceStatic > 0) {
                    analysisText = `El objeto se moverá **hacia abajo** del plano. La fuerza neta es de ${netForceStatic.toFixed(2)} N.`;
                    behaviorText = `La fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es mayor que la fuerza de fricción (${frictionForce.toFixed(2)} N).`;
                } else if (netForceStatic < 0) {
                    analysisText = `El objeto está en **equilibrio estático**.`;
                    behaviorText = `La fuerza de fricción (${frictionForce.toFixed(2)} N) es mayor que la fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N), lo que impide el movimiento.`;
                } else {
                    analysisText = `El objeto está en **equilibrio estático**.`;
                    behaviorText = `La fuerza gravitatoria paralela es exactamente igual a la fuerza de fricción.`;
                }
                
                displacementText = `El objeto solo se desplaza hacia abajo si la fuerza neta es positiva. Se detiene al llegar a la longitud máxima del plano (${currentLength.toFixed(2)} M).`;
            }
            
            movementAnalysis.innerHTML = analysisText;
            systemBehavior.innerHTML = behaviorText;
            displacementExplanation.innerHTML = displacementText;
        }

        function startSimulation() {
            if (isRunning) return; 
            
            // Validaciones
            if (usePulley) {
                if (parseFloat(massInputPulley.value) <= 0 || parseFloat(counterMassInput.value) <= 0) {
                    showNotification('Error', 'Las masas deben ser mayores a 0.', 'error');
                    return;
                }
            } else {
                if (parseFloat(massInput.value) <= 0) {
                    showNotification('Error', 'La masa debe ser mayor a 0.', 'error');
                    return;
                }
            }

            isRunning = true;
            isPaused = false;
            startBtn.textContent = 'Simulación en Curso...';
            startBtn.disabled = true;
            pauseBtn.textContent = 'Pausar';
            
            lastTime = performance.now();
            animationId = requestAnimationFrame(animate);
            showNotification('Simulación Iniciada', 'El movimiento del objeto ha comenzado.', 'info');
        }

        function resetSimulation() {
            cancelAnimationFrame(animationId);
            isRunning = false;
            isPaused = false;
            currentTime = 0;
            position = 0;
            velocity = 0;
            acceleration = 0;
            netForce = 0;
            energy = 0;
            simulationData = [];

            // Actualizar DOM
            timeValue.textContent = '0.00 s';
            positionValue.textContent = '0.00 M';
            velocityValue.textContent = '0.00 M/s';
            accelerationValue.textContent = '0.00 M/s²';
            forceValue.textContent = '0.00 N';
            energyValue.textContent = '0.00 J';
            
            startBtn.textContent = 'Iniciar Simulación';
            startBtn.disabled = false;
            pauseBtn.textContent = 'Pausar';

            // Redibujar el estado inicial
            drawSimulation();
            updateResultsExplanation();
            showNotification('Simulación Reiniciada', 'Todos los parámetros se han restablecido al estado inicial.', 'warning');
        }

        function exportData() {
            if (simulationData.length === 0) {
                showNotification('Advertencia', 'No hay datos para exportar. Inicie una simulación primero.', 'warning');
                return;
            }

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Tiempo (s),Posicion (M),Velocidad (M/s),Aceleracion (M/s²),Fuerza Neta (N),Energia (J)\n";

            simulationData.forEach(item => {
                let row = `${item.time.toFixed(3)},${item.position.toFixed(3)},${item.velocity.toFixed(3)},${item.acceleration.toFixed(3)},${item.netForce.toFixed(3)},${item.energy.toFixed(3)}`;
                csvContent += row + "\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "datos_plano_inclinado.csv");
            document.body.appendChild(link); // Requerido para Firefox
            link.click();
            document.body.removeChild(link);
            
            showNotification('Datos Exportados', 'Los datos de la simulación han sido exportados como CSV.', 'success');
        }

        function saveConfiguration() {
            const config = {
                timestamp: new Date().toLocaleString(),
                type: usePulley ? 'Polea' : 'Básico',
                mass: usePulley ? parseFloat(massInputPulley.value) : parseFloat(massInput.value),
                angle: usePulley ? parseFloat(angleInputPulley.value) : parseFloat(angleInput.value),
                friction: usePulley ? parseFloat(frictionInputPulley.value) : parseFloat(frictionInput.value),
                length: usePulley ? parseFloat(lengthInputPulley.value) : parseFloat(lengthInput.value),
                gravity: usePulley ? parseFloat(gravityInputPulley.value) : parseFloat(gravityInput.value),
                counterMass: usePulley ? parseFloat(counterMassInput.value) : null
            };

            configHistory.unshift(config);
            if (configHistory.length > 10) {
                configHistory.pop(); // Mantener solo las últimas 10 configuraciones
            }
            localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
            renderHistory();
            showNotification('Configuración Guardada', `Configuración ${config.type} (${config.angle}°) guardada en el historial.`, 'success');
        }

        function loadConfiguration(index) {
            const config = configHistory[index];
            if (!config) return;

            // Cambiar pestaña si es necesario
            const targetTabId = config.type === 'Polea' ? 'pulley' : 'basic';
            document.querySelector(`.tab[data-tab="${targetTabId}"]`).click();
            
            // Cargar valores
            if (config.type === 'Básico') {
                massInput.value = config.mass;
                angleInput.value = config.angle;
                angleRange.value = config.angle;
                frictionInput.value = config.friction;
                frictionRange.value = config.friction;
                lengthInput.value = config.length;
                gravityInput.value = config.gravity;
            } else { // Polea
                massInputPulley.value = config.mass;
                angleInputPulley.value = config.angle;
                angleRangePulley.value = config.angle;
                frictionInputPulley.value = config.friction;
                frictionRangePulley.value = config.friction;
                lengthInputPulley.value = config.length;
                gravityInputPulley.value = config.gravity;
                counterMassInput.value = config.counterMass;
            }
            
            // Forzar actualización de variables y dibujo
            updateParams();
            drawSimulation();
            updateResultsExplanation();
            resetSimulation(); // Asegurar que la simulación se reinicia con la nueva config
            showNotification('Configuración Cargada', `Configuración ${config.type} (${config.angle}°) cargada y lista para iniciar.`, 'info');
        }
        
        function deleteConfiguration(index) {
            configHistory.splice(index, 1);
            localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
            renderHistory();
            showNotification('Configuración Eliminada', 'La configuración ha sido eliminada del historial.', 'warning');
        }

        function renderHistory() {
            historyList.innerHTML = '';
            if (configHistory.length === 0) {
                emptyHistory.style.display = 'block';
                return;
            }
            emptyHistory.style.display = 'none';

            configHistory.forEach((config, index) => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <div class="history-details">
                        <div class="history-title">${config.type} - θ: ${config.angle}°</div>
                        <div class="history-params">
                            M: ${config.mass} Kg, 
                            ${config.type === 'Polea' ? `M₂: ${config.counterMass} Kg, ` : ''}
                            μ: ${config.friction.toFixed(2)}, 
                            L: ${config.length} M
                        </div>
                        <div class="history-date">${config.timestamp}</div>
                    </div>
                    <div class="history-actions">
                        <button class="history-btn-small load" data-index="${index}">Cargar</button>
                        <button class="history-btn-small delete" data-index="${index}">Eliminar</button>
                    </div>
                `;
                historyList.appendChild(item);
            });

            document.querySelectorAll('.history-btn-small.load').forEach(btn => {
                btn.addEventListener('click', (e) => loadConfiguration(parseInt(e.target.dataset.index)));
            });
            document.querySelectorAll('.history-btn-small.delete').forEach(btn => {
                btn.addEventListener('click', (e) => deleteConfiguration(parseInt(e.target.dataset.index)));
            });
        }
        
        // Función para actualizar los parámetros globales a partir de los inputs
        function updateParams() {
            if (document.getElementById('basic-tab').classList.contains('active')) {
                usePulley = false;
                mass = parseFloat(massInput.value);
                angle = parseFloat(angleInput.value);
                friction = parseFloat(frictionInput.value);
                length = parseFloat(lengthInput.value);
                gravity = parseFloat(gravityInput.value);
            } else {
                usePulley = true;
                mass = parseFloat(massInputPulley.value);
                angle = parseFloat(angleInputPulley.value);
                friction = parseFloat(frictionInputPulley.value);
                length = parseFloat(lengthInputPulley.value);
                gravity = parseFloat(gravityInputPulley.value);
                pulleyConfig.counterMass = parseFloat(counterMassInput.value);
            }
            // Actualizar valores en los rangos y viceversa para mantener sincronía
            updateRangeValues();
        }
        
        function updateRangeValues() {
            angleValue.textContent = `${angleRange.value}°`;
            angleInput.value = angleRange.value;
            frictionValue.textContent = parseFloat(frictionRange.value).toFixed(2);
            frictionInput.value = frictionRange.value;
            
            angleValuePulley.textContent = `${angleRangePulley.value}°`;
            angleInputPulley.value = angleRangePulley.value;
            frictionValuePulley.textContent = parseFloat(frictionRangePulley.value).toFixed(2);
            frictionInputPulley.value = frictionRangePulley.value;
        }

        // ----------------------------------------------------------------------
        // Event Listeners
        // ----------------------------------------------------------------------

        // Manejar Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                this.classList.add('active');
                document.getElementById(`${this.dataset.tab}-tab`).classList.add('active');
                
                // Forzar actualización y redibujo al cambiar de pestaña
                updateParams();
                drawSimulation();
                updateResultsExplanation();
            });
        });

        // Sincronizar inputs numéricos y rangos, y redibujar
        document.querySelectorAll('input[type="range"]').forEach(range => {
            range.addEventListener('input', function() {
                updateParams();
                drawSimulation();
                updateResultsExplanation();
                // Si la simulación está pausada, al cambiar parámetros se vuelve a dibujar.
                if (!isRunning || isPaused) {
                    drawSimulation();
                }
            });
        });
        
        document.querySelectorAll('input[type="number"]').forEach(input => {
            input.addEventListener('change', function() {
                updateParams();
                drawSimulation();
                updateResultsExplanation();
            });
        });
        
        // Botones de control
        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                // resetSimulation() se llama implícitamente al cargar config. 
                // Pero si no hay config cargada, se asegura que los parámetros están correctos y la simulación se inicializa.
                updateParams();
                startSimulation();
            } else if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = "Pausar";
                animate();
                showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
            }
        });
       
        pauseBtn.addEventListener('click', function() {
            if (isRunning) {
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? "Continuar" : "Pausar";
                if (!isPaused) {
                    animate();
                    showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
                } else {
                    cancelAnimationFrame(animationId);
                    showNotification('Simulación Pausada', 'La simulación ha sido pausada.', 'info');
                }
            }
        });
       
        resetBtn.addEventListener('click', function() {
            resetSimulation();
        });
       
        exportBtn.addEventListener('click', exportData);
        saveConfigBtn.addEventListener('click', saveConfiguration);
       
        // Inicialización
        window.addEventListener('load', function() {
            setupCanvas();
            updateParams();
            drawSimulation();
            updateResultsExplanation();
            showNotification('Bienvenido', 'El laboratorio virtual de plano inclinado está listo. Configure los parámetros y presione "Iniciar Simulación".', 'info');
        });
       
        window.addEventListener('resize', function() {
            setupCanvas();
            drawSimulation();
        });
    </script>
</body>
</html>
