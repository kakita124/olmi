<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual - Plano Inclinado</title>
    <style>
        :root {
            --primary-color: #1a365d;
            --secondary-color: #2d3748;
            --accent-color: #3182ce;
            --light-color: #f7fafc;
            --dark-color: #1a202c;
            --success-color: #38a169;
            --warning-color: #d69e2e;
            --danger-color: #e53e3e;
            --text-color: #2d3748;
            --border-radius: 10px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }
       
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
       
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }
       
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
       
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
       
        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--success-color));
        }
       
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .header-title {
            flex: 1;
        }
       
        h1 {
            font-size: 1.2rem;
            margin-bottom: 5px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }
       
        .subtitle {
            font-size: 0.8rem;
            opacity: 0.85;
            font-weight: 400;
        }
       
        .content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 25px;
            margin-bottom: 30px;
        }
       
        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
       
        .panel {
            background: white;
            border-radius: var(--border-radius);
            padding: 28px;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .panel:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .panel h2 {
            margin-bottom: 22px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e2e8f0;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }
       
        .panel h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 22px;
            background: var(--accent-color);
            margin-right: 12px;
            border-radius: 2px;
        }
       
        .tabs {
            display: flex;
            margin-bottom: 22px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 8px 8px 0 0;
            padding: 5px;
        }
       
        .tab {
            padding: 12px 22px;
            cursor: pointer;
            border-radius: 6px;
            transition: var(--transition);
            font-weight: 500;
            flex: 1;
            text-align: center;
            color: var(--secondary-color);
        }
       
        .tab.active {
            background: white;
            color: var(--accent-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
       
        .tab:hover:not(.active) {
            background: rgba(49, 130, 206, 0.05);
        }
       
        .tab-content {
            display: none;
        }
       
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
       
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
       
        .input-group {
            margin-bottom: 22px;
        }
       
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--secondary-color);
            font-size: 0.95rem;
        }
       
        input[type="number"], select {
            width: 100%;
            padding: 14px;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
            background: white;
        }
       
        input[type="number"]:focus, select:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.15);
        }
       
        .input-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
       
        .input-container input {
            flex: 1;
        }
       
        .unit {
            min-width: 45px;
            text-align: center;
            font-weight: 500;
            color: var(--secondary-color);
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
       
        .range-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
       
        .range-container input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
       
        .range-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
       
        .range-value {
            min-width: 45px;
            text-align: center;
            font-weight: 600;
            background: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            color: var(--primary-color);
            /* Asegura que el texto se renderice sin problemas, necesario para MathJax */
            overflow: hidden; 
        }
       
        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 14px 22px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: var(--transition);
            width: 100%;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
       
        button:hover {
            background: #2c5aa0;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
       
        .simulation-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
       
        .canvas-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            flex: 1;
            min-height: 450px;
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .canvas-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: var(--border-radius);
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }
       
        .data-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 18px;
            margin-top: 22px;
        }
       
        .data-item {
            background: white;
            padding: 18px;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border-left: 4px solid var(--accent-color);
        }
       
        .data-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
       
        .data-label {
            font-size: 0.9rem;
            color: var(--secondary-color);
            margin-bottom: 8px;
            font-weight: 500;
        }
       
        .data-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--primary-color);
        }
       
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 22px;
        }
       
        .controls button {
            flex: 1;
            margin-top: 0;
        }
       
        .reset-btn {
            background: var(--danger-color);
        }
       
        .reset-btn:hover {
            background: #c53030;
        }
       
        .pause-btn {
            background: var(--warning-color);
        }
       
        .pause-btn:hover {
            background: #b7791f;
        }
       
        .export-btn {
            background: var(--success-color);
        }
       
        .export-btn:hover {
            background: #2f855a;
        }
       
        .pulley-config {
            margin-top: 22px;
            padding-top: 22px;
            border-top: 1px solid #e2e8f0;
        }
       
        .pulley-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 18px;
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
        }
       
        .pulley-toggle input {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
        }
       
        .pulley-options {
            padding: 18px;
            background: #f8fafc;
            border-radius: var(--border-radius);
            margin-top: 12px;
            border: 1px solid #e2e8f0;
        }
       
        .history-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            min-height: 320px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .history-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .history-list {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 10px;
        }
       
        .history-item {
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid var(--accent-color);
            transition: var(--transition);
        }
       
        .history-item:hover {
            background: #edf2f7;
            transform: translateX(5px);
        }
       
        .history-details {
            flex: 1;
        }
       
        .history-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
       
        .history-params {
            font-size: 0.85rem;
            color: var(--secondary-color);
        }
       
        .history-date {
            font-size: 0.8rem;
            color: var(--secondary-color);
            margin-top: 3px;
        }
       
        .history-actions {
            display: flex;
            gap: 8px;
        }
       
        .history-btn-small {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: var(--transition);
        }
       
        .history-btn-small:hover {
            background: #2c5aa0;
        }
       
        .history-btn-small.delete {
            background: var(--danger-color);
        }
       
        .history-btn-small.delete:hover {
            background: #c53030;
        }
       
        .empty-history {
            text-align: center;
            padding: 30px;
            color: var(--secondary-color);
            font-style: italic;
        }
       
        footer {
            text-align: center;
            padding: 25px;
            margin-top: 35px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            font-size: 0.95rem;
            color: var(--secondary-color);
            border-top: 4px solid var(--accent-color);
        }
       
        .info-panel {
            background: white;
            border-radius: var(--border-radius);
            padding: 28px;
            box-shadow: var(--box-shadow);
            margin-top: 25px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .info-panel:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .info-panel h2 {
            margin-bottom: 18px;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }
       
        .info-panel h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 22px;
            background: var(--accent-color);
            margin-right: 12px;
            border-radius: 2px;
        }
       
        .formula {
            background: #f8fafc;
            padding: 18px;
            border-radius: var(--border-radius);
            margin: 18px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            border-left: 4px solid var(--accent-color);
            font-weight: 600;
            color: var(--primary-color);
        }
       
        .variable {
            font-style: italic;
            color: var(--accent-color);
            font-weight: 500;
        }
       
        .theory-content {
            line-height: 1.8;
        }
       
        .theory-content p {
            margin-bottom: 18px;
        }
       
        .validation-message {
            color: var(--danger-color);
            font-size: 0.9rem;
            margin-top: 8px;
            display: none;
            font-weight: 500;
        }
       
        .icon {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
       
        /* Estilos para el sistema de notificaciones */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        }
       
        .notification {
            background: white;
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-left: 4px solid var(--accent-color);
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease;
        }
       
        .notification-icon {
            margin-right: 10px;
            font-size: 1.2rem;
        }
       
        .notification-content {
            flex: 1;
        }
       
        .notification-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--primary-color);
        }
       
        .notification-message {
            font-size: 0.9rem;
            color: var(--secondary-color);
            line-height: 1.4;
        }
       
        .notification-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 0;
            margin: 0;
            width: auto;
        }
       
        .notification-close:hover {
            color: var(--danger-color);
            transform: none;
            box-shadow: none;
        }
       
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
       
        /* Estilos para la sección de resultados */
        .results-container {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            margin-top: 25px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
       
        .results-container:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
       
        .results-explanation {
            background: #f8fafc;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 15px;
            border-left: 4px solid var(--success-color);
        }
       
        .results-explanation h4 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }
       
        .results-explanation p {
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-title">
                    <h1>Laboratorio Virtual: Plano Inclinado</h1>
                    <p class="subtitle">Simulador interactivo para el estudio de la física del movimiento</p>
                </div>
            </div>
        </header>
       
        <div class="content">
            <div class="panel">
                <h2>Configuración del Experimento</h2>
               
                <div class="tabs">
                    <div class="tab active" data-tab="basic">Básico</div>
                    <div class="tab" data-tab="pulley">Poleas</div>
                </div>
               
                <div class="tab-content active" id="basic-tab">
                    <div class="input-group">
                        <label for="mass-input">Masa del objeto (M)</label>
                        <div class="input-container">
                            <input type="number" id="mass-input" min="0.1" value="5" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                        <div class="validation-message" id="mass-validation"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="angle-input">Ángulo del plano (θ)</label>
                        <div class="range-container">
                            <input type="range" id="angle-range" min="1" max="90" value="30" step="1">
                            <span class="range-value" id="angle-value">30°</span> 
                        </div>
                        <input type="number" id="angle-input" min="1" max="90" value="30" step="1" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="friction-input">Coeficiente de fricción (μ)</label>
                        <div class="range-container">
                            <input type="range" id="friction-range" min="0" max="1" value="0.1" step="0.01">
                            <span class="range-value" id="friction-value">0.10</span>
                        </div>
                        <input type="number" id="friction-input" min="0" max="1" value="0.1" step="0.01" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="length-input">Longitud del plano (L)</label>
                        <div class="input-container">
                            <input type="number" id="length-input" min="1" value="8" step="0.5">
                            <span class="unit">M</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="gravity-input">Gravedad (g)</label>
                        <div class="input-container">
                            <input type="number" id="gravity-input" value="9.8" min="1" step="0.1">
                            <span class="unit">M/s²</span>
                        </div>
                    </div>
                </div>
               
                <div class="tab-content" id="pulley-tab">
                    <div class="input-group">
                        <label for="mass-input-pulley">Masa del objeto (M)</label>
                        <div class="input-container">
                            <input type="number" id="mass-input-pulley" min="0.1" value="5" step="0.1">
                            <span class="unit">Kg</span>
                        </div>
                        <div class="validation-message" id="mass-validation-pulley"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="counter-mass-input">Masa contrapeso (M₂)</label>
                        <div class="input-container">
                            <input type="number" id="counter-mass-input" min="0.1" value="3" step="0.1">
                            <span class="unit">kg</span>
                        </div>
                        <div class="validation-message" id="counter-mass-validation"></div>
                    </div>
                   
                    <div class="input-group">
                        <label for="angle-input-pulley">Ángulo del plano (θ)</label>
                        <div class="range-container">
                            <input type="range" id="angle-range-pulley" min="1" max="90" value="30" step="1">
                            <span class="range-value" id="angle-value-pulley">30°</span> 
                        </div>
                        <input type="number" id="angle-input-pulley" min="1" max="90" value="30" step="1" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="friction-input-pulley">Coeficiente de fricción (μ)</label>
                        <div class="range-container">
                            <input type="range" id="friction-range-pulley" min="0" max="1" value="0.1" step="0.01">
                            <span class="range-value" id="friction-value-pulley">0.10</span>
                        </div>
                        <input type="number" id="friction-input-pulley" min="0" max="1" value="0.1" step="0.01" style="display: none;">
                    </div>
                   
                    <div class="input-group">
                        <label for="length-input-pulley">Longitud del plano (L)</label>
                        <div class="input-container">
                            <input type="number" id="length-input-pulley" min="1" value="8" step="0.5">
                            <span class="unit">M</span>
                        </div>
                    </div>
                   
                    <div class="input-group">
                        <label for="gravity-input-pulley">Gravedad (g)</label>
                        <div class="input-container">
                            <input type="number" id="gravity-input-pulley" value="9.8" min="1" step="0.1">
                            <span class="unit">M/s²</span>
                        </div>
                    </div>
                </div>
               
                <button id="start-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Iniciar Simulación
                </button>
                <button id="save-config-btn" style="background: var(--success-color);">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                    Guardar Configuración
                </button>
                <button id="reset-btn" class="reset-btn">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                    </svg>
                    Reiniciar
                </button>
            </div>
           
            <div class="simulation-area">
                <div class="canvas-container">
                    <h2>Visualización del Experimento</h2>
                    <canvas id="simulation-canvas"></canvas>
                </div>
               
                <div class="data-display">
                    <div class="data-item">
                        <div class="data-label">Tiempo</div>
                        <div class="data-value" id="time-value">0.00 s</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Posición</div>
                        <div class="data-value" id="position-value">0.00 M</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Velocidad</div>
                        <div class="data-value" id="velocity-value">0.00 M/s</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Aceleración</div>
                        <div class="data-value" id="acceleration-value">0.00 M/s²</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Fuerza Net</div>
                        <div class="data-value" id="force-value">0.00 N</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Energía</div>
                        <div class="data-value" id="energy-value">0.00 J</div>
                    </div>
                </div>
               
                <div class="controls">
                    <button id="pause-btn" class="pause-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                        Pausar
                    </button>
                    <button id="export-btn" class="export-btn">
                        <svg class="icon" viewBox="0 0 24 24">
                            <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                        </svg>
                        Exportar Datos
                    </button>
                </div>
               
                <div class="history-container">
                    <h2>Historial de Configuraciones</h2>
                    <div class="history-list" id="history-list">
                        <div class="empty-history" id="empty-history">No hay configuraciones guardadas. Guarda una configuración para verla aquí.</div>
                    </div>
                </div>
            </div>
        </div>
       
        <div class="results-container">
            <h2>Resultados y Explicación del Sistema</h2>
            <div class="results-explanation">
                <h4>Análisis del Movimiento</h4>
                <p id="movement-analysis">El sistema está en reposo. Inicie la simulación para ver el análisis del movimiento.</p>
                <h4>Comportamiento del Sistema</h4>
                <p id="system-behavior">El objeto permanecerá en reposo o se moverá dependiendo de la relación entre la fuerza gravitatoria paralela al plano y la fuerza de fricción.</p>
                <h4>Explicación del Desplazamiento</h4>
                <p id="displacement-explanation">El desplazamiento del objeto está determinado por la fuerza neta que actúa sobre él. Si la componente gravitatoria paralela al plano supera la fuerza de fricción, el objeto acelerará hacia abajo del plano.</p>
            </div>
        </div>
       
        <div class="info-panel">
            <h2>Fundamentos Teóricos</h2>
            <div class="tabs">
                <div class="tab active" data-tab="theory">Teoría</div>
                <div class="tab" data-tab="formulas">Fórmulas</div>
                <div class="tab" data-tab="instructions">Instrucciones</div>
            </div>
            <div class="tab-content active" id="theory-tab">
                <div class="theory-content">
                    <p>Un plano inclinado es una superficie plana que forma un ángulo agudo con la horizontal. Se utiliza para elevar cuerpos a una cierta altura con una fuerza menor que el peso del cuerpo.</p>
                    <p>Las fuerzas que actúan sobre un objeto en un plano inclinado son:</p>
                    <ul>
                        <li><span class="variable">Peso (mg)</span>: Fuerza gravitatoria dirigida hacia el centro de la Tierra.</li>
                        <li><span class="variable">Fuerza normal (N)</span>: Fuerza perpendicular al plano ejercida por la superficie.</li>
                        <li><span class="variable">Fuerza de fricción (f)</span>: Fuerza que se opone al movimiento, paralela al plano.</li>
                    </ul>
                    <p>Cuando se añade un sistema de poleas, se introduce una fuerza adicional que puede modificar el movimiento del objeto en el plano inclinado.</p>
                </div>
            </div>
            <div class="tab-content" id="formulas-tab">
                <div class="theory-content">
                    <p><strong>Fuerzas en un plano inclinado (Serway):</strong></p>
                    <div class="formula"> F<sub>gx</sub> = mg sen θ </div>
                    <div class="formula"> F<sub>gy</sub> = mg cos θ </div>
                    <div class="formula"> F<sub>n</sub> = mg cos θ </div>
                    <div class="formula"> f<sub>k</sub> = μ<sub>k</sub> F<sub>n</sub> = μ<sub>k</sub> mg cos θ </div>
                    <div class="formula"> F<sub>neta</sub> = mg sen θ - f<sub>k</sub> </div>
                    <div class="formula"> a = F<sub>neta</sub> / m </div>
                    <p><strong>Con sistema de poleas:</strong></p>
                    <div class="formula"> F<sub>neta</sub> = mg sen θ - f<sub>k</sub> - T </div>
                    <div class="formula"> T = m<sub>2</sub>g - m<sub>2</sub>a </div>
                </div>
            </div>
            <div class="tab-content" id="instructions-tab">
                <div class="theory-content">
                    <p>Instrucciones del sistema:</p>
                    <ul>
                        <li><strong>Primer paso:</strong> Seleccionar el sistema que desee utilzar (Básico o con polea).</li>
                        <li><strong>Segundo paso:</strong> Insertar datos correspondientes al sistema seleccionado y apretar el boton de iniciar simulación.</li>
                        <li><strong>Tercer paso:</strong> Al detenerse, se puede utilizar la opción reiniciar o exportar datos, al exportarlos se entregará un documento.</li>
                        <li><strong>Nueva función:</strong> Puede guardar configuraciones para usarlas posteriormente desde el panel de historial.</li>
                    </ul>
                </div>
            </div>
        </div>
       
        <footer>
            <p>Laboratorio Virtual de Física - Simulador de Plano Inclinado con Poleas y sin poleas</p>
            <p>© 2023 - Departamento de Física - Universidad Virtual</p>
        </footer>
    </div>
   
    <div class="notification-container" id="notification-container"></div>

    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script>
      MathJax = {
        tex: {
          inlineMath: [['\\(', '\\)']] // Configura \\( y \\) como delimitadores para matemáticas en línea
        }
      };
    </script>
    <script>
        // Elementos del DOM
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
       
        // Inputs numéricos
        const massInput = document.getElementById('mass-input');
        const angleInput = document.getElementById('angle-input');
        const angleRange = document.getElementById('angle-range');
        const angleValue = document.getElementById('angle-value');
        const frictionInput = document.getElementById('friction-input');
        const frictionRange = document.getElementById('friction-range');
        const frictionValue = document.getElementById('friction-value');
        const lengthInput = document.getElementById('length-input');
        const gravityInput = document.getElementById('gravity-input');
       
        // Inputs de la pestaña Poleas
        const massInputPulley = document.getElementById('mass-input-pulley');
        const angleInputPulley = document.getElementById('angle-input-pulley');
        const angleRangePulley = document.getElementById('angle-range-pulley');
        const angleValuePulley = document.getElementById('angle-value-pulley');
        const frictionInputPulley = document.getElementById('friction-input-pulley');
        const frictionRangePulley = document.getElementById('friction-range-pulley');
        const frictionValuePulley = document.getElementById('friction-value-pulley');
        const lengthInputPulley = document.getElementById('length-input-pulley');
        const gravityInputPulley = document.getElementById('gravity-input-pulley');
       
        // Configuración de poleas
        const counterMassInput = document.getElementById('counter-mass-input');
       
        // Botones
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const exportBtn = document.getElementById('export-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
       
        // Historial
        const historyList = document.getElementById('history-list');
        const emptyHistory = document.getElementById('empty-history');
       
        // Valores de datos
        const timeValue = document.getElementById('time-value');
        const positionValue = document.getElementById('position-value');
        const velocityValue = document.getElementById('velocity-value');
        const accelerationValue = document.getElementById('acceleration-value');
        const forceValue = document.getElementById('force-value');
        const energyValue = document.getElementById('energy-value');
       
        // Mensajes de validación
        const massValidation = document.getElementById('mass-validation');
        const massValidationPulley = document.getElementById('mass-validation-pulley');
        const counterMassValidation = document.getElementById('counter-mass-validation');
       
        // Elementos de resultados
        const movementAnalysis = document.getElementById('movement-analysis');
        const systemBehavior = document.getElementById('system-behavior');
        const displacementExplanation = document.getElementById('displacement-explanation');
       
        // Variables de simulación
        let animationId;
        let isRunning = false;
        let isPaused = false;
        let currentTime = 0;
        let position = 0;
        let velocity = 0;
        let acceleration = 0;
        let netForce = 0;
        let energy = 0;
        let simulationData = [];
       
        // Parámetros iniciales
        let mass = parseFloat(massInput.value);
        let angle = parseFloat(angleInput.value);
        let friction = parseFloat(frictionInput.value);
        let length = parseFloat(lengthInput.value);
        let gravity = parseFloat(gravityInput.value);
        let usePulley = false;
        let pulleyConfig = {
            counterMass: parseFloat(counterMassInput.value)
        };
       
        // Variables para controlar notificaciones
        let angleChanged = false;
        let frictionChanged = false;
       
        // Historial de configuraciones
        let configHistory = JSON.parse(localStorage.getItem('inclinedPlaneHistory')) || [];
       
        // Pestañas
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        let activeTab = 'basic';
       
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                activeTab = tab.dataset.tab;
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(activeTab + '-tab').classList.add('active');
                
                // Sincronizar parámetros al cambiar de pestaña
                synchronizeParameters();
                // Actualizar la simulación si no está corriendo
                if (!isRunning) {
                    drawSimulation();
                }
            });
        });
       
        function synchronizeParameters() {
            if (activeTab === 'basic') {
                // Sincronizar de la pestaña poleas a la básica (para visualización en el canvas)
                angleInput.value = angleRangePulley.value;
                frictionInput.value = frictionRangePulley.value;
                massInput.value = massInputPulley.value;
                lengthInput.value = lengthInputPulley.value;
                gravityInput.value = gravityInputPulley.value;
                
                // Actualizar las variables de simulación con los valores de la pestaña activa (poleas en este caso)
                mass = parseFloat(massInputPulley.value);
                angle = parseFloat(angleRangePulley.value);
                friction = parseFloat(frictionRangePulley.value);
                length = parseFloat(lengthInputPulley.value);
                gravity = parseFloat(gravityInputPulley.value);
                usePulley = true; // Si estamos en la pestaña de poleas, la usamos
                pulleyConfig.counterMass = parseFloat(counterMassInput.value);
               
            } else if (activeTab === 'pulley') {
                // Sincronizar de la pestaña básica a la de poleas (para visualización en el canvas)
                angleInputPulley.value = angleRange.value;
                frictionInputPulley.value = frictionRange.value;
                massInputPulley.value = massInput.value;
                lengthInputPulley.value = lengthInput.value;
                gravityInputPulley.value = gravityInput.value;
                
                // Actualizar las variables de simulación con los valores de la pestaña activa (básica en este caso)
                mass = parseFloat(massInput.value);
                angle = parseFloat(angleRange.value);
                friction = parseFloat(frictionRange.value);
                length = parseFloat(lengthInput.value);
                gravity = parseFloat(gravityInput.value);
                usePulley = false; // Si estamos en la pestaña básica, no usamos poleas
                pulleyConfig.counterMass = parseFloat(counterMassInput.value); // Se mantiene pero no se usa
            }
        }
       
        // Inicializar el historial
        renderHistory();
       
        // Función para mostrar notificaciones
        function showNotification(title, message, type = 'info') {
            const notificationContainer = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = 'notification';
            let icon = 'ℹ️';
            if (type === 'warning') icon = '⚠️';
            if (type === 'error') icon = '❌';
            if (type === 'success') icon = '✅';
            notification.innerHTML = `
                <div class="notification-icon">${icon}</div>
                <div class="notification-content">
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close">&times;</button>
            `;
            notificationContainer.appendChild(notification);
       
            // Cerrar notificación al hacer clic en la X
            notification.querySelector('.notification-close').addEventListener('click', function() {
                notification.remove();
            });
       
            // Auto-eliminar después de 5 segundos
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }
       
        // Función de validación de entradas
        function validateInput(inputElement, validationElement, min, max, name) {
            const value = parseFloat(inputElement.value);
            let isValid = true;
            let message = '';
       
            if (isNaN(value)) {
                isValid = false;
                message = `La ${name} no puede estar vacía.`;
            } else if (value < min) {
                isValid = false;
                message = `La ${name} debe ser mayor o igual a ${min}.`;
            } else if (value > max) {
                isValid = false;
                message = `La ${name} debe ser menor o igual a ${max}.`;
            }
       
            if (!isValid) {
                validationElement.textContent = message;
                validationElement.style.display = 'block';
            } else {
                validationElement.style.display = 'none';
            }
            return isValid;
        }
       
        // Función para actualizar la sección de resultados
        function updateResultsExplanation() {
            const angleRad = angle * Math.PI / 180;
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            const normalForce = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * normalForce;
            let netForceValue = gravitationalForce - frictionForce;
       
            // Análisis del movimiento
            if (netForceValue > 0) {
                movementAnalysis.textContent = `El objeto se está moviendo hacia abajo del plano. La fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es mayor que la fuerza de fricción (${frictionForce.toFixed(2)} N).`;
            } else if (netForceValue < 0) {
                movementAnalysis.textContent = `El objeto se está moviendo hacia arriba del plano. La fuerza de fricción (${frictionForce.toFixed(2)} N) es mayor que la fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N).`;
            } else {
                movementAnalysis.textContent = `El objeto está en equilibrio. La fuerza gravitatoria paralela (${gravitationalForce.toFixed(2)} N) es igual a la fuerza de fricción (${frictionForce.toFixed(2)} N).`;
            }
       
            // Comportamiento del sistema
            if (usePulley) {
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                systemBehavior.textContent = `El sistema de poleas está activado. El contrapeso de ${pulleyConfig.counterMass} kg ejerce una fuerza de ${counterWeightForce.toFixed(2)} N.`;
            } else {
                systemBehavior.textContent = `El sistema de poleas está desactivado. El movimiento está determinado únicamente por la gravedad y la fricción.`;
            }
       
            // Explicación del desplazamiento
            if (acceleration > 0) {
                displacementExplanation.textContent = `El objeto está acelerando hacia abajo del plano con una aceleración de ${acceleration.toFixed(2)} m/s². La velocidad aumenta con el tiempo.`;
            } else if (acceleration < 0) {
                displacementExplanation.textContent = `El objeto está desacelerando (aceleración negativa de ${acceleration.toFixed(2)} m/s²). La velocidad disminuye con el tiempo.`;
            } else {
                displacementExplanation.textContent = `El objeto se mueve con velocidad constante o está en reposo. No hay aceleración neta.`;
            }
        }
       
        // Función para actualizar los parámetros
        function updateParameters() {
            let angleChangedLocal = false;
            let frictionChangedLocal = false;
            let currentAngle = angle;
            let currentFriction = friction;
       
            // Basic Tab
            if (activeTab === 'basic') {
                mass = parseFloat(massInput.value);
                angle = parseFloat(angleRange.value);
                friction = parseFloat(frictionRange.value);
                length = parseFloat(lengthInput.value);
                gravity = parseFloat(gravityInput.value);
       
                // ********** PASO 2A: APLICAR FORMATO LATEX/MATHJAX **********
                // Usamos innerHTML con la sintaxis de LaTeX: \mathbf{\alpha = 30^\circ}
                angleValue.innerHTML = `\\( \\mathbf{\\alpha = ${angle}^\\circ} \\)`; 
                // *************************************************************
                frictionValue.textContent = friction.toFixed(2);
       
                // Update pulley inputs for synchronization (hidden)
                angleInput.value = angle;
                frictionInput.value = friction;
       
                usePulley = false;
       
            // Pulley Tab
            } else if (activeTab === 'pulley') {
                mass = parseFloat(massInputPulley.value);
                angle = parseFloat(angleRangePulley.value);
                friction = parseFloat(frictionRangePulley.value);
                length = parseFloat(lengthInputPulley.value);
                gravity = parseFloat(gravityInputPulley.value);
                pulleyConfig.counterMass = parseFloat(counterMassInput.value);
       
                // ********** PASO 2B: APLICAR FORMATO LATEX/MATHJAX **********
                // Usamos innerHTML con la sintaxis de LaTeX: \mathbf{\alpha = 30^\circ}
                angleValuePulley.innerHTML = `\\( \\mathbf{\\alpha = ${angle}^\\circ} \\)`;
                // *************************************************************
                frictionValuePulley.textContent = friction.toFixed(2);
                
                usePulley = true;
       
            }
       
            if (currentAngle !== angle) angleChangedLocal = true;
            if (currentFriction !== friction) frictionChangedLocal = true;
       
            // Sincronizar inputs numéricos y sliders
            angleRange.value = angle;
            angleRangePulley.value = angle;
            frictionRange.value = friction;
            frictionRangePulley.value = friction;
       
            // ********** PASO 3: FORZAR RENDERIZADO DE MATHJAX **********
            // Asegúrate de que MathJax haya cargado antes de llamar typesetPromise
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                // Renderizar ambos elementos de ángulo para asegurar que se actualicen en ambas pestañas
                MathJax.typesetPromise([angleValue, angleValuePulley]).catch((err) => console.log('MathJax Typeset Error: ' + err));
            }
            // *************************************************************
       
            // Update data display and explanation
            updateResultsExplanation();
            // Re-draw simulation if not running
            if (!isRunning) {
                drawSimulation();
            }
       
            // Notificaciones de cambio de parámetros
            if (angleChangedLocal) angleChanged = true;
            if (frictionChangedLocal) frictionChanged = true;
       
            if (isRunning && (angleChangedLocal || frictionChangedLocal)) {
                showNotification('¡Parámetros cambiados!', 'La simulación se ha reiniciado automáticamente con los nuevos parámetros.', 'warning');
                resetSimulation();
                isRunning = true;
                isPaused = false;
                startBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar Simulación';
                animate();
            }
        }
       
        // Guardar configuración actual
        saveConfigBtn.addEventListener('click', function() {
            let isValid = true;
            if (activeTab === 'basic') {
                isValid &= validateInput(massInput, massValidation, 0.1, 1000, 'masa');
            } else {
                isValid &= validateInput(massInputPulley, massValidationPulley, 0.1, 1000, 'masa');
                isValid &= validateInput(counterMassInput, counterMassValidation, 0.1, 1000, 'masa contrapeso');
            }
            
            if (!isValid) {
                showNotification('Error de Validación', 'Corrija los valores de entrada antes de guardar.', 'error');
                return;
            }
            
            const configName = prompt("Ingrese un nombre para esta configuración:", `Configuración ${new Date().toLocaleTimeString()}`);
            if (configName) {
                const config = {
                    id: Date.now(),
                    name: configName,
                    timestamp: new Date().toISOString(),
                    params: {
                        mass: activeTab === 'basic' ? parseFloat(massInput.value) : parseFloat(massInputPulley.value),
                        angle: activeTab === 'basic' ? parseFloat(angleRange.value) : parseFloat(angleRangePulley.value),
                        friction: activeTab === 'basic' ? parseFloat(frictionRange.value) : parseFloat(frictionRangePulley.value),
                        length: activeTab === 'basic' ? parseFloat(lengthInput.value) : parseFloat(lengthInputPulley.value),
                        gravity: activeTab === 'basic' ? parseFloat(gravityInput.value) : parseFloat(gravityInputPulley.value),
                        usePulley: activeTab === 'pulley',
                        pulleyConfig: {
                            counterMass: activeTab === 'pulley' ? parseFloat(counterMassInput.value) : null
                        }
                    }
                };
       
                // Agregar al inicio del array
                configHistory.unshift(config);
       
                // Limitar a 10 configuraciones
                if (configHistory.length > 10) {
                    configHistory = configHistory.slice(0, 10);
                }
       
                // Guardar en localStorage
                localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
       
                // Actualizar vista
                renderHistory();
                showNotification('Configuración Guardada', `La configuración "${configName}" se ha guardado correctamente.`, 'success');
            }
        });
       
        // Renderizar historial
        function renderHistory() {
            if (configHistory.length === 0) {
                emptyHistory.style.display = 'block';
                historyList.innerHTML = '';
                historyList.appendChild(emptyHistory);
                return;
            }
            emptyHistory.style.display = 'none';
            historyList.innerHTML = '';
            configHistory.forEach(config => {
                const item = document.createElement('div');
                item.className = 'history-item';
                const date = new Date(config.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
       
                let paramsStr = `M: ${config.params.mass} kg, \\(\\mathbf{\\alpha = ${config.params.angle}^\\circ}\\), μ: ${config.params.friction.toFixed(2)}`;
                if (config.params.usePulley) {
                    paramsStr += `, M₂: ${config.params.pulleyConfig.counterMass} kg (Polea)`;
                } else {
                    paramsStr += ` (Básico)`;
                }
       
                item.innerHTML = `
                    <div class="history-details">
                        <div class="history-title">${config.name}</div>
                        <div class="history-params" id="params-${config.id}">${paramsStr}</div>
                        <div class="history-date">${dateStr}</div>
                    </div>
                    <div class="history-actions">
                        <button class="history-btn-small load-btn" data-id="${config.id}">Cargar</button>
                        <button class="history-btn-small delete delete-btn" data-id="${config.id}">Eliminar</button>
                    </div>
                `;
                historyList.appendChild(item);
                
                // Forzar renderizado MathJax para el historial
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([document.getElementById(`params-${config.id}`)]).catch((err) => console.log('MathJax History Typeset Error: ' + err));
                }
            });
       
            document.querySelectorAll('.load-btn').forEach(btn => {
                btn.addEventListener('click', loadConfig);
            });
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', deleteConfig);
            });
        }
       
        // Cargar configuración del historial
        function loadConfig(event) {
            const configId = parseInt(event.target.dataset.id);
            const config = configHistory.find(c => c.id === configId);
            
            if (config) {
                // Actualizar inputs
                if (config.params.usePulley) {
                    document.querySelector('.tab[data-tab="pulley"]').click();
                    massInputPulley.value = config.params.mass;
                    angleRangePulley.value = config.params.angle;
                    frictionRangePulley.value = config.params.friction;
                    lengthInputPulley.value = config.params.length;
                    gravityInputPulley.value = config.params.gravity;
                    counterMassInput.value = config.params.pulleyConfig.counterMass;
                } else {
                    document.querySelector('.tab[data-tab="basic"]').click();
                    massInput.value = config.params.mass;
                    angleRange.value = config.params.angle;
                    frictionRange.value = config.params.friction;
                    lengthInput.value = config.params.length;
                    gravityInput.value = config.params.gravity;
                }
       
                // Forzar actualización de parámetros
                updateParameters();
                // Reiniciar simulación
                resetSimulation();
                showNotification('Configuración Cargada', `La configuración "${config.name}" ha sido cargada.`, 'success');
            }
        }
       
        // Eliminar configuración del historial
        function deleteConfig(event) {
            const configId = parseInt(event.target.dataset.id);
            if (confirm("¿Está seguro de que desea eliminar esta configuración?")) {
                configHistory = configHistory.filter(c => c.id !== configId);
                localStorage.setItem('inclinedPlaneHistory', JSON.stringify(configHistory));
                renderHistory();
                showNotification('Configuración Eliminada', 'La configuración ha sido eliminada del historial.', 'info');
            }
        }
       
        // Configuración inicial del canvas
        function setupCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
       
        // Dibuja el plano inclinado y el objeto
        function drawSimulation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
       
            const width = canvas.width;
            const height = canvas.height;
            const angleRad = angle * Math.PI / 180;
            const scale = width / (length * 1.5); // Escala para ajustar la longitud al ancho del canvas
            const baseLength = length * scale;
            const baseHeight = baseLength * Math.tan(angleRad);
            const boxSize = 30;
       
            // Asegurar que la altura no sea mayor que el canvas
            if (baseHeight > height * 0.8) {
                const factor = (height * 0.8) / baseHeight;
                baseHeight = height * 0.8;
                baseLength *= factor;
            }
       
            // Coordenadas de los puntos del plano
            const P1 = { x: 50, y: height - 50 }; // Base inferior izquierda
            const P2 = { x: P1.x + baseLength, y: P1.y }; // Base inferior derecha
            const P3 = { x: P1.x + baseLength, y: P1.y - baseHeight }; // Cima
            // P4 es la proyección de P3 sobre el suelo (P1.x + baseLength - baseLength * cos(angleRad) * cos(angleRad) ??? No, P4 es P1.x)
            const P4 = { x: P1.x, y: P1.y - baseHeight }; // Cima proyectada
            
            // Punto de referencia para el objeto (caja)
            // position va de 0 a baseLength.
            // La posición real en X y Y debe estar sobre la hipotenusa (P1 a P3)
            const currentPosition = position * scale;
            
            // X e Y en el sistema del canvas (a lo largo del plano inclinado)
            const boxXCenter = P1.x + currentPosition * Math.cos(angleRad);
            const boxYCenter = P1.y - currentPosition * Math.sin(angleRad);
       
            // Dibujar el plano inclinado (Triángulo)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // (50, H-50)
            ctx.lineTo(P2.x, P2.y); // Base (Suelo)
            ctx.lineTo(P3.x, P3.y); // Cima
            ctx.closePath();
            ctx.fillStyle = '#cbd5e0';
            ctx.fill();
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 2;
            ctx.stroke();
       
            // Dibujar el objeto (Caja)
            ctx.save();
            // Trasladar el origen al punto central de la caja
            ctx.translate(boxXCenter, boxYCenter);
            // Rotar para alinear con el ángulo del plano
            ctx.rotate(-angleRad);
            
            // Dibujar la caja centrada en el nuevo origen (boxXCenter, boxYCenter)
            ctx.fillStyle = '#e53e3e';
            ctx.fillRect(-boxSize / 2, -boxSize / 2, boxSize, boxSize);
            ctx.strokeStyle = '#c53030';
            ctx.lineWidth = 1;
            ctx.strokeRect(-boxSize / 2, -boxSize / 2, boxSize, boxSize);
       
            // Restaurar el sistema de coordenadas
            ctx.restore();
       
            // Dibujar el ángulo alfa (alfa)
            const angleRadius = 40;
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y);
            ctx.lineTo(P1.x + angleRadius, P1.y);
            ctx.arc(P1.x, P1.y, angleRadius, 0, -angleRad, true);
            ctx.lineTo(P1.x, P1.y);
            ctx.fillStyle = 'rgba(49, 130, 206, 0.2)';
            ctx.fill();
            ctx.strokeStyle = var(--accent-color);
            ctx.lineWidth = 1;
            ctx.stroke();
       
            // Dibujar el texto del ángulo (alpha)
            ctx.save();
            ctx.translate(P1.x, P1.y);
            ctx.rotate(-angleRad / 2);
            ctx.fillStyle = var(--primary-color);
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Usamos innerHTML con MathJax/KaTeX para el rango, pero aquí solo usamos texto simple para el canvas
            ctx.fillText(`α = ${angle}°`, angleRadius + 5, 0); 
            ctx.restore();
       
            // Dibujar la polea y el contrapeso si se usa
            if (usePulley) {
                const pulleyRadius = 15;
                const pulleyCenter = { x: P3.x - pulleyRadius / 2, y: P3.y + pulleyRadius };
                
                // Polea
                ctx.beginPath();
                ctx.arc(pulleyCenter.x, pulleyCenter.y, pulleyRadius, 0, 2 * Math.PI);
                ctx.fillStyle = '#a0aec0';
                ctx.fill();
                ctx.strokeStyle = '#4a5568';
                ctx.lineWidth = 2;
                ctx.stroke();
       
                // Cuerda
                ctx.beginPath();
                // Cuerda sobre el plano
                ctx.moveTo(boxXCenter + boxSize/2 * Math.cos(angleRad), boxYCenter - boxSize/2 * Math.sin(angleRad)); // Desde la caja
                ctx.lineTo(pulleyCenter.x - pulleyRadius * Math.cos(angleRad), pulleyCenter.y + pulleyRadius * Math.sin(angleRad)); // Hacia la polea
                // Cuerda colgante
                ctx.moveTo(pulleyCenter.x + pulleyRadius * Math.cos(angleRad) * Math.cos(angleRad), pulleyCenter.y + pulleyRadius * Math.sin(angleRad) * Math.sin(angleRad)); // Desde la polea
                ctx.lineTo(pulleyCenter.x + pulleyRadius, pulleyCenter.y + pulleyRadius);
                ctx.strokeStyle = '#4a5568';
                ctx.lineWidth = 1;
                ctx.stroke();
       
                // Contrapeso (M2)
                const counterMassSize = 30;
                ctx.fillStyle = '#38a169';
                ctx.fillRect(pulleyCenter.x - counterMassSize / 2, pulleyCenter.y + pulleyRadius + counterMassSize / 2, counterMassSize, counterMassSize);
                ctx.strokeStyle = '#2f855a';
                ctx.lineWidth = 1;
                ctx.strokeRect(pulleyCenter.x - counterMassSize / 2, pulleyCenter.y + pulleyRadius + counterMassSize / 2, counterMassSize, counterMassSize);
            }
        }
       
        // Cálculo de aceleración (A = Fnet/M)
        function calculateAcceleration() {
            const angleRad = angle * Math.PI / 180;
            const mgSin = mass * gravity * Math.sin(angleRad);
            const mgCos = mass * gravity * Math.cos(angleRad);
            const frictionForce = friction * mgCos;
            
            if (usePulley) {
                const m2 = pulleyConfig.counterMass;
                const m1 = mass;
                // Aceleración en sistema de poleas: a = (m1*g*sinθ - f_k + m2*g) / (m1 + m2)
                // Depende de la dirección del movimiento, asumiremos la dirección por la fuerza neta:
                // F_net = T - f_k - m1*g*sinθ
                // T = m2*(g - a)
                // F_net = m2*g - m2*a - f_k - m1*g*sinθ
                // (m1 + m2)*a = m2*g - f_k - m1*g*sinθ
                // a = (m2*g - m1*g*sinθ - f_k) / (m1 + m2)
                
                // Fuerza Neta
                netForce = (m2 * gravity) - mgSin - frictionForce;
                acceleration = netForce / (m1 + m2);
                
            } else {
                // Fricción se opone al movimiento, aquí asumimos que el movimiento es hacia abajo (mgSin > fricción)
                if (mgSin > frictionForce) {
                    netForce = mgSin - frictionForce;
                } else if (mgSin < frictionForce) {
                    // Si el objeto fue lanzado hacia arriba, la fricción se suma a mgSin.
                    // Aquí asumimos que el objeto comienza en reposo:
                    netForce = 0;
                    acceleration = 0;
                } else {
                    netForce = 0;
                    acceleration = 0;
                }
                
                // Si la fuerza neta es positiva, hay aceleración.
                if (netForce > 0) {
                    acceleration = netForce / mass;
                } else {
                    acceleration = 0;
                }
            }
        }
       
        // Lógica de simulación (bucle de animación)
        let lastTime = 0;
        function animate(timestamp) {
            if (!isRunning || isPaused) {
                return;
            }
       
            const deltaTime = (timestamp - lastTime) / 1000 || 0;
            lastTime = timestamp;
       
            calculateAcceleration(); // Recalcula la aceleración
       
            // Ecuaciones de movimiento (Euler o Runge-Kutta para mayor precisión)
            // Usando Euler simple por ahora:
            velocity += acceleration * deltaTime;
            position += velocity * deltaTime + 0.5 * acceleration * deltaTime * deltaTime;
            currentTime += deltaTime;
       
            // Condición de detención: Objeto sale del plano (posición > longitud)
            if (position >= length) {
                position = length;
                velocity = 0;
                acceleration = 0;
                isRunning = false;
                startBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Iniciar Simulación';
                showNotification('Simulación Terminada', 'El objeto ha llegado al final del plano.', 'success');
            }
       
            // Si la velocidad se vuelve negativa y la aceleración es positiva (o viceversa), puede que se detenga
            // En un caso real, la fricción debe cambiar de dirección. Para esta simulación simple, asumiremos que se detiene.
            if (velocity < 0 && netForce < 0) {
                velocity = 0;
                acceleration = 0;
                netForce = 0;
            }
       
            // Cálculo de Energía (Simplificado: solo cinética + potencial gravitacional relativa a la base)
            const heightReached = position * Math.sin(angleRad);
            const potentialEnergy = mass * gravity * heightReached;
            const kineticEnergy = 0.5 * mass * velocity * velocity;
            energy = potentialEnergy + kineticEnergy;
            
            // Recopilar datos
            simulationData.push({
                time: currentTime,
                position: position,
                velocity: velocity,
                acceleration: acceleration,
                netForce: netForce,
                energy: energy
            });
       
            // Actualizar display de datos
            timeValue.textContent = `${currentTime.toFixed(2)} s`;
            positionValue.textContent = `${position.toFixed(2)} M`;
            velocityValue.textContent = `${velocity.toFixed(2)} M/s`;
            accelerationValue.textContent = `${acceleration.toFixed(2)} M/s²`;
            forceValue.textContent = `${netForce.toFixed(2)} N`;
            energyValue.textContent = `${energy.toFixed(2)} J`;
       
            // Re-dibujar
            drawSimulation();
            updateResultsExplanation();
       
            if (isRunning) {
                animationId = requestAnimationFrame(animate);
            }
        }
       
        // Iniciar Simulación
        startBtn.addEventListener('click', function() {
            let isValid = true;
            if (activeTab === 'basic') {
                isValid &= validateInput(massInput, massValidation, 0.1, 1000, 'masa');
            } else {
                isValid &= validateInput(massInputPulley, massValidationPulley, 0.1, 1000, 'masa');
                isValid &= validateInput(counterMassInput, counterMassValidation, 0.1, 1000, 'masa contrapeso');
            }
            
            if (!isValid) {
                showNotification('Error de Validación', 'Corrija los valores de entrada antes de iniciar la simulación.', 'error');
                return;
            }
            
            if (!isRunning) {
                isRunning = true;
                isPaused = false;
                startBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar Simulación';
                lastTime = performance.now();
                showNotification('Simulación Iniciada', 'El objeto está ahora en movimiento.', 'info');
                animate(lastTime);
            } else if (isPaused) {
                isPaused = false;
                startBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar Simulación';
                lastTime = performance.now();
                animate(lastTime);
                showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
            } else {
                isPaused = true;
                startBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Continuar Simulación';
                showNotification('Simulación Pausada', 'La simulación ha sido pausada.', 'info');
            }
        });
       
        // Pausar/Continuar Simulación
        pauseBtn.addEventListener('click', function() {
            if (isRunning) {
                isPaused = !isPaused;
                pauseBtn.innerHTML = isPaused ? '<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Continuar' : '<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar';
                if (!isPaused) {
                    lastTime = performance.now();
                    animate(lastTime);
                    showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
                } else {
                    showNotification('Simulación Pausada', 'La simulación ha sido pausada.', 'info');
                }
            }
        });
       
        // Reiniciar Simulación
        function resetSimulation() {
            cancelAnimationFrame(animationId);
            isRunning = false;
            isPaused = false;
            currentTime = 0;
            position = 0;
            velocity = 0;
            acceleration = 0;
            netForce = 0;
            energy = 0;
            simulationData = [];
            angleChanged = false;
            frictionChanged = false;
       
            startBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Iniciar Simulación';
            pauseBtn.innerHTML = '<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar';
       
            // Resetear display de datos
            timeValue.textContent = '0.00 s';
            positionValue.textContent = '0.00 M';
            velocityValue.textContent = '0.00 M/s';
            accelerationValue.textContent = '0.00 M/s²';
            forceValue.textContent = '0.00 N';
            energyValue.textContent = '0.00 J';
            
            // Re-dibujar el estado inicial
            drawSimulation();
            updateResultsExplanation();
            showNotification('Simulación Reiniciada', 'La simulación ha vuelto a su estado inicial.', 'info');
        }
       
        resetBtn.addEventListener('click', resetSimulation);
       
        // Exportar datos
        function exportData() {
            if (simulationData.length === 0) {
                showNotification('Exportar Error', 'No hay datos de simulación para exportar. Inicie la simulación primero.', 'error');
                return;
            }
       
            let csvContent = "Tiempo (s),Posición (M),Velocidad (M/s),Aceleración (M/s²),Fuerza Neta (N),Energía (J)\n";
            simulationData.forEach(row => {
                csvContent += `${row.time.toFixed(2)},${row.position.toFixed(2)},${row.velocity.toFixed(2)},${row.acceleration.toFixed(2)},${row.netForce.toFixed(2)},${row.energy.toFixed(2)}\n`;
            });
       
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "datos_plano_inclinado.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification('Exportación Exitosa', 'Los datos de la simulación han sido exportados como CSV.', 'success');
        }
       
        exportBtn.addEventListener('click', exportData);
       
        // Escuchadores de eventos para actualizar los parámetros
        angleRange.addEventListener('input', updateParameters);
        angleRange.addEventListener('change', updateParameters);
        frictionRange.addEventListener('input', updateParameters);
        frictionRange.addEventListener('change', updateParameters);
        
        angleRangePulley.addEventListener('input', updateParameters);
        angleRangePulley.addEventListener('change', updateParameters);
        frictionRangePulley.addEventListener('input', updateParameters);
        frictionRangePulley.addEventListener('change', updateParameters);
       
        massInput.addEventListener('input', updateParameters);
        massInput.addEventListener('change', updateParameters);
        lengthInput.addEventListener('input', updateParameters);
        lengthInput.addEventListener('change', updateParameters);
        gravityInput.addEventListener('input', updateParameters);
        gravityInput.addEventListener('change', updateParameters);
       
        massInputPulley.addEventListener('input', updateParameters);
        massInputPulley.addEventListener('change', updateParameters);
        lengthInputPulley.addEventListener('input', updateParameters);
        lengthInputPulley.addEventListener('change', updateParameters);
        gravityInputPulley.addEventListener('input', updateParameters);
        gravityInputPulley.addEventListener('change', updateParameters);
        counterMassInput.addEventListener('input', updateParameters);
        counterMassInput.addEventListener('change', updateParameters);
       
        // Inicialización
        window.addEventListener('load', function() {
            setupCanvas();
            // Necesario llamar a updateParameters para que el valor inicial '30' se renderice como LaTeX.
            updateParameters(); 
            drawSimulation();
            showNotification('Bienvenido', 'El laboratorio virtual de plano inclinado está listo. Configure los parámetros y presione "Iniciar Simulación".', 'info');
        });
       
        window.addEventListener('resize', function() {
            setupCanvas();
            drawSimulation();
        });
       
        // Pausar/Continuar Simulación
        // NOTA: El botón startBtn ya maneja la pausa/continuar, por lo que el botón pauseBtn es redundante.
        // Lo mantengo por si la intención es tener dos botones con distintas funcionalidades, pero lo comento.
        /*
        pauseBtn.addEventListener('click', function() {
            if (isRunning) {
                isPaused = !isPaused;
                pauseBtn.innerHTML = isPaused ? '<svg class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> Continuar' : '<svg class="icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Pausar';
                if (!isPaused) {
                    lastTime = performance.now();
                    animate(lastTime);
                    showNotification('Simulación Reanudada', 'La simulación ha sido reanudada.', 'info');
                } else {
                    showNotification('Simulación Pausada', 'La simulación ha sido pausada.', 'info');
                }
            }
        });
        */
        
    </script>
</body>
</html>
