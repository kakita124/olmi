<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Plano Inclinado con Poleas</title>
    <style>
        /* Estilos anteriores... */
        
        /* Nuevos estilos para notificaciones */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: #e74c3c;
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            max-width: 300px;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .notification.success {
            background: #27ae60;
        }
        
        .notification.warning {
            background: #f39c12;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Contenido anterior... -->
    </div>
    
    <!-- Notificación para mostrar mensajes -->
    <div id="notification" class="notification"></div>

    <script>
        // Elementos del DOM (código anterior...)
        
        // Elemento de notificación
        const notification = document.getElementById('notification');
        
        // Función para mostrar notificaciones
        function showNotification(message, type = 'error') {
            notification.textContent = message;
            notification.className = 'notification';
            notification.classList.add(type);
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }
        
        // Función para verificar si el bloque se moverá
        function willBlockMove() {
            const angleRad = angle * Math.PI / 180;
            
            // Fuerza gravitatoria paralela al plano
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
            
            // Fuerza normal
            const normalForce = mass * gravity * Math.cos(angleRad);
            
            // Fuerza de fricción estática máxima
            const maxStaticFriction = friction * normalForce;
            
            // Verificar si hay suficiente fuerza para vencer la fricción estática
            if (gravitationalForce <= maxStaticFriction) {
                return false;
            }
            
            // Si hay poleas, verificar el sistema completo
            if (usePulley) {
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                const pulleyEfficiency = 1 - pulleyConfig.pulleyFriction;
                
                let effectiveForce;
                if (pulleyConfig.type === 'fixed') {
                    effectiveForce = gravitationalForce - counterWeightForce * pulleyEfficiency;
                } else if (pulleyConfig.type === 'movable') {
                    effectiveForce = gravitationalForce - (counterWeightForce * pulleyEfficiency) / 2;
                } else if (pulleyConfig.type === 'compound') {
                    effectiveForce = gravitationalForce - (counterWeightForce * pulleyEfficiency) / 3;
                }
                
                // Si la fuerza efectiva es menor que la fricción, no hay movimiento
                if (effectiveForce <= maxStaticFriction) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Calcular física del plano inclinado - CORREGIDA CON VERIFICACIÓN DE MOVIMIENTO
        function calculatePhysics() {
            const angleRad = angle * Math.PI / 180;
           
            // Fuerza gravitatoria paralela al plano
            const gravitationalForce = mass * gravity * Math.sin(angleRad);
           
            // Fuerza normal
            const normalForce = mass * gravity * Math.cos(angleRad);
           
            // Fuerza de fricción
            const frictionForce = friction * normalForce;
           
            // Fuerza neta inicial
            let netForceValue = gravitationalForce - frictionForce;
           
            // Aplicar sistema de poleas si está activado
            if (usePulley) {
                const counterWeightForce = pulleyConfig.counterMass * gravity;
                const pulleyEfficiency = 1 - pulleyConfig.pulleyFriction;
               
                if (pulleyConfig.type === 'fixed') {
                    netForceValue = gravitationalForce - frictionForce - counterWeightForce * pulleyEfficiency;
                } else if (pulleyConfig.type === 'movable') {
                    netForceValue = gravitationalForce - frictionForce - (counterWeightForce * pulleyEfficiency) / 2;
                } else if (pulleyConfig.type === 'compound') {
                    netForceValue = gravitationalForce - frictionForce - (counterWeightForce * pulleyEfficiency) / 3;
                }
            }
           
            // Calcular masa efectiva para sistemas con poleas
            let effectiveMass = mass;
            if (usePulley) {
                if (pulleyConfig.type === 'movable') {
                    effectiveMass = mass + pulleyConfig.counterMass / 2;
                } else if (pulleyConfig.type === 'compound') {
                    effectiveMass = mass + pulleyConfig.counterMass / 3;
                } else {
                    effectiveMass = mass + pulleyConfig.counterMass;
                }
            }
           
            // Aceleración - CORREGIDA: Si la fuerza neta es insuficiente, aceleración = 0
            if (netForceValue <= 0) {
                acceleration = 0;
                velocity = 0;
            } else {
                acceleration = netForceValue / effectiveMass;
            }
           
            // Actualizar velocidad y posición
            const deltaTime = 0.016; // Aproximadamente 60 FPS
           
            if (isRunning && !isPaused && acceleration > 0) {
                velocity += acceleration * deltaTime;
               
                // No permitir velocidad negativa si el objeto está en la parte superior
                if (position <= 0 && velocity < 0) {
                    velocity = 0;
                    position = 0;
                }
               
                // No permitir que el objeto sobrepase la longitud del plano
                if (position >= length && velocity > 0) {
                    velocity = 0;
                    position = length;
                    isRunning = false;
                    showNotification("El bloque ha llegado al final del plano", "success");
                } else {
                    position += velocity * deltaTime;
                }
               
                currentTime += deltaTime;
            }
           
            // Calcular energía
            const heightFromTop = (length - position) * Math.sin(angleRad);
            const potentialEnergy = mass * gravity * heightFromTop;
            const kineticEnergy = 0.5 * mass * velocity * velocity;
            energy = potentialEnergy + kineticEnergy;
           
            netForce = netForceValue;
           
            // Actualizar valores en pantalla
            timeValue.textContent = currentTime.toFixed(2) + " s";
            positionValue.textContent = position.toFixed(2) + " m";
            velocityValue.textContent = velocity.toFixed(2) + " m/s";
            accelerationValue.textContent = acceleration.toFixed(2) + " m/s²";
            forceValue.textContent = netForce.toFixed(2) + " N";
            energyValue.textContent = energy.toFixed(2) + " J";
           
            // Guardar datos para exportación
            if (isRunning && !isPaused) {
                simulationData.push({
                    time: currentTime,
                    position: position,
                    velocity: velocity,
                    acceleration: acceleration,
                    force: netForce,
                    energy: energy
                });
            }
        }
        
        // Controladores de botones CORREGIDOS con verificación de movimiento
        startBtn.addEventListener('click', function() {
            // Verificar si el bloque se moverá antes de iniciar
            if (!willBlockMove()) {
                showNotification("La fuerza no es suficiente para mover el bloque. Ajusta los parámetros.", "warning");
                return;
            }
            
            if (!isRunning) {
                isRunning = true;
                isPaused = false;
                pauseBtn.textContent = "Pausar";
                // Reiniciar datos al iniciar nueva simulación
                if (currentTime === 0) {
                    simulationData = [];
                }
                animate();
            } else if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = "Pausar";
                animate();
            }
        });
        
        // Resto del código anterior...
    </script>
</body>
</html>
